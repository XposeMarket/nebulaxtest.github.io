<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>NEBULAX • Portfolio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
<script src="nx-theme.js"></script>
<!-- 1) Solana web3 must be present before nx-wallet -->
<script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>

<!-- 2) Match the same wallet helper + RPC used on Home -->
<script>
  window.NX_RPC = "https://rpc.helius.xyz/?api-key=3858d764-530d-4b75-b3df-619dc2613ff9";
</script>
<script src="assets/nx-wallet.js"></script>

    
    <script>
document.addEventListener("DOMContentLoaded", async () => {
  // Sync profile picture from platform avatar or store state
  function updatePfp() {
    try {
      const pfpImg = document.getElementById('nx-pfp');
      console.log('PFP element found:', !!pfpImg);
      
      if(!pfpImg) {
        console.log('PFP element not found, retrying...');
        setTimeout(updatePfp, 500);
        return;
      }

      // First try the platform avatar key (set by store when avatar changes)
      let avatarSrc = localStorage.getItem('nx_platform_avatar');
      console.log('nx_platform_avatar:', avatarSrc);
      
      // If not found, try to get from store state
      if (!avatarSrc) {
        const storeState = JSON.parse(localStorage.getItem('nx_store_state_v3') || '{}');
        avatarSrc = storeState.profile?.avatar;
        console.log('from store state:', avatarSrc);
      }
      
      // Default to logo if nothing found
      if (!avatarSrc) {
        console.log('Using default logo');
        avatarSrc = 'NebulaX-logo.png';
      }
      
      console.log('Setting avatar src to:', avatarSrc);
      pfpImg.src = avatarSrc;
      pfpImg.onerror = () => { 
        console.log('Image failed to load, using fallback');
        pfpImg.src = 'NebulaX-logo.png'; 
      };
      pfpImg.onload = () => {
        console.log('Image loaded successfully:', avatarSrc);
      };
    } catch(e) {
      console.error('Error updating PFP:', e);
      const pfpImg = document.getElementById('nx-pfp');
      if(pfpImg) pfpImg.src = 'NebulaX-logo.png';
    }
  }
  
  // Small delay to ensure DOM is ready
  setTimeout(updatePfp, 100);

  // Listen for avatar changes from store
  window.addEventListener('nebula:avatar:changed', (e) => {
    console.log('Avatar changed event received:', e.detail?.avatar);
    const pfpImg = document.getElementById('nx-pfp');
    if(pfpImg && e.detail?.avatar) {
      pfpImg.src = e.detail.avatar;
      pfpImg.onerror = () => { 
        console.log('Image failed to load, using fallback');
        pfpImg.src = 'NebulaX-logo.png'; 
      };
      pfpImg.onload = () => {
        console.log('Image loaded successfully:', e.detail.avatar);
      };
    }
  });

  const btn  = document.getElementById("wallet-btn");
  const cash = document.getElementById("pv-cash"); // Cash (SOL) tile

  function paint(sol){
    if (!btn) return;
    if (sol == null) {
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Connect Wallet`;
    } else {
      const s = sol.toFixed(3);
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Available: ${s} SOL`;
      if (cash) cash.textContent = s;
    }
    try { window.lucide?.createIcons?.(); } catch {}
  }

  // Use the same NXWallet instance as Home
  if (window.NXWallet?.isConnected?.()) {
    try { await window.NXWallet.refreshBalance?.(true); } catch {}
    paint(window.NXWallet?.getBalance?.());
  } else {
    // trust-only reconnect (no popup) if user already connected on this origin
    const prov = (window.phantom?.solana) || window.solana;
    try { await prov?.connect?.({ onlyIfTrusted: true }); } catch {}
    if (window.NXWallet?.isConnected?.()) {
      try { await window.NXWallet.refreshBalance?.(true); } catch {}
      paint(window.NXWallet?.getBalance?.());
    } else {
      paint(null);
    }
  }

  // stay in sync with homepage events
  window.addEventListener("nebula:sol:changed", (e)=> paint(e.detail?.balance));
  window.addEventListener("nxwallet:connected", async ()=>{
    try { await window.NXWallet.refreshBalance?.(true); } catch {}
    paint(window.NXWallet?.getBalance?.());
  });
  window.addEventListener("nxwallet:disconnected", ()=> paint(null));
});
</script>

<!-- your portfolio live module or page scripts after this -->
<style>
  :root {
    --nx-cyan:#00e6ff; --nx-dark:#0a0d1b; --nx-dark-2:#12152a;
    --nx-border:#1e2747; --nx-text:#e0e7ff;
  }
  html[data-theme="amber"]{ --nx-cyan:#ffb020; --nx-dark:#0b0b14; --nx-dark-2:#15162a; --nx-border:#2a2647; --nx-text:#ffeccc; }
  html[data-theme="violet"]{ --nx-cyan:#b69cff; --nx-dark:#0a0a16; --nx-dark-2:#131329; --nx-border:#27224a; --nx-text:#eae4ff; }
  html[data-theme="neon"]{ --nx-cyan:#55ffda; --nx-dark:#070b12; --nx-dark-2:#0d1220; --nx-border:#1a243a; --nx-text:#dbfff7; }

  .nx-tab { padding:.4rem .6rem; border-radius:.7rem; border:1px solid transparent; font-size:.85rem; }
  .nx-tab.active { border-color:var(--nx-border); background:rgba(255,255,255,.03); color:var(--nx-cyan); }
  .nx-btn { font-size:.8rem; padding:.35rem .6rem; border-radius:.6rem; border:1px solid var(--nx-border); }
  .nx-btn-outline { font-size:.8rem; padding:.35rem .6rem; border-radius:.6rem; border:1px dashed var(--nx-border); background:transparent; }
  input::placeholder { color: #7a86a8; }
</style>
    <style>
      :root{ --nx-cyan:#00e6ff; --nx-dark:#0a0d1b; --nx-dark-2:#12152a; --nx-border:#1e2747; --nx-text:#e0e7ff; --page-max: 1400px; }
      html,body{height:100%; background:var(--nx-dark); font-family:'Orbitron','ui-monospace','SFMono-Regular',monospace; color:var(--nx-text);}  
      .page-wrap{max-width:var(--page-max); margin:18px auto; padding:0 12px;}

      .nx-panel{ background:rgba(16,20,40,.92); border:1px solid var(--nx-border); box-shadow: inset 0 0 10px rgba(0,230,255,.18), 0 0 12px rgba(0,230,255,.08); backdrop-filter: blur(8px); border-radius: 16px; }
      .nx-title{color:#ffeb3b;text-shadow:0 0 3px #ffeb3b;}
      .tabnums{font-variant-numeric: tabular-nums;}

      .nx-btn{ border-radius:14px; padding:.42rem .72rem; font-weight:700; transition:transform .05s ease, opacity .18s ease, box-shadow .18s ease; border:1px solid var(--nx-border); background:var(--nx-dark-2); color:var(--nx-text);} 
      .nx-btn:hover{opacity:.95}
      .nx-btn:active{transform:translateY(1px)}
      .nx-btn-cyan{ background:var(--nx-cyan); color:#0b101b; border-color:#0d3540; box-shadow:0 0 10px rgba(0,230,255,.3); }

      .nx-input{ width:100%; border-radius:12px; border:1px solid var(--nx-border); background:var(--nx-dark-2); color:var(--nx-text); padding:.55rem .7rem; outline:none; }
      .nx-input:focus{border-color:var(--nx-cyan); box-shadow:0 0 0 2px rgba(0,230,255,.14)}

      .nx-table{ width:100%; border-collapse:separate; border-spacing:0; }
      .nx-th, .nx-td{ padding:10px 10px; text-align:left; border-bottom:0; }
      thead .nx-th{ position:sticky; top:0; z-index:20; user-select:none; background:rgba(32,36,64,.95); color:#ffeb3b; text-shadow:0 0 3px #ffeb3b; border-bottom:1px solid var(--nx-border); }
      tbody tr{ position:relative; }
      tbody tr::after{ content:""; position:absolute; left:0; right:0; bottom:0; height:1px; background:#333a66; pointer-events:none; }
      tbody tr:hover{ background:rgba(10,14,28,.6); box-shadow: inset 0 0 0 1px rgba(0,230,255,.08); }

      .pos-green{ color:#10b981; } /* emerald-500 */
      .pos-red{ color:#ef4444; }   /* red-500 */
      .pos-cyan{ color: var(--nx-cyan); }
      .pos-yellow{ color:#ffeb3b; }
    
      /* Modal overlay (Deposit / Withdraw) */
      .modal-fx{
        position:fixed; inset:0; display:grid; place-items:center; z-index:2100;
        background:rgba(0,0,0,.55); padding:12px;
      }
      .modal-fx.hidden{ display:none !important; }

      .search-dd{overflow:auto;border:1px solid var(--nx-border);background:rgba(13,16,34,.98);}
      .search-head{position:sticky;top:0;padding:8px 12px;font-size:12px;letter-spacing:.08em;color:#9aa6dc;border-bottom:1px solid var(--nx-border);background:rgba(18,22,40,.96)}
      .result-item{display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid var(--nx-border)}
      .result-item:hover{background:rgba(18,22,46,.98)}
      .ri-left{width:28px;height:28px;border-radius:10px;background:rgba(20,24,48,.9);display:flex;align-items:center;justify-content:center;border:1px solid var(--nx-border)}
      .ri-main{flex:1;min-width:0}
      .ri-pair{font-weight:800;letter-spacing:.02em}
      .ri-name{font-size:12px;color:#cfd6ff;opacity:.8;margin-top:2px}
      .ri-metrics{display:flex;gap:12px;font-size:12px;white-space:nowrap}
      .ri-metrics .lab{color:#9aa6dc;margin-right:4px}
      .row-card.highlight{box-shadow:inset 0 0 0 1px rgba(0,230,255,.35),0 0 12px rgba(0,230,255,.12);border-radius:12px}

      }
    
    </style>
  </head>
  <body>
    <!-- Header -->
    <header class="sticky top-0 z-[1000] isolate border-b border-[var(--nx-border)] bg-[rgba(10,13,27,0.9)] backdrop-blur-sm">
      <div class="page-wrap h-7 px-1 flex items-center justify-between">
        <div class="flex items-center gap-3">
          <a href="NebulaX.html" class="flex items-center gap-2">
            <img src="NebulaX-logo.png" class="h-6 w-6 rounded-md" alt="NebulaX"/>
            <span class="font-bold tracking-wide" style="text-shadow:0 0 2px var(--nx-cyan);">NEBULAX</span>
          </a>
          <nav class="hidden sm:flex items-center gap-2 ml-2">
            <a class="nx-btn px-2 py-1 text-xs" href="NebulaX.html">Home</a>
            <a class="nx-btn px-2 py-1 text-xs" href="NewPairs-official.html">New Pairs</a>
            <a class="nx-btn px-2 py-1 text-xs" href="Trending.html">Trending</a>
            <a class="nx-btn px-2 py-1 text-xs" href="portfolio_official_v_2_fixed.html">Portfolio</a>
            <a class="nx-btn px-2 py-1 text-xs" href="Adrenaline-official.html">Adrenaline</a>
            <a class="nx-btn px-2 py-1 text-xs" href="nebula_x_store_official.html">Store</a>
            <a class="nx-btn px-2 py-1 text-xs" href="NEBX-Arcade.html">Arcade</a>
          </nav>
        </div>

  <!-- Center: SEARCH -->
  <div id="search-wrap" class="relative w-[26rem] max-w-[60vw] hidden md:block">
    <input id="search-input" class="nx-input" placeholder="Search markets... /" autocomplete="off"/>
    <div id="search-dd" class="popover hidden mt-1 w-full max-h-[22rem] overflow-auto p-2"></div>
  </div>

  <!-- Wallet + Profile -->
  <div class="flex items-center gap-2">
    <button id="wallet-btn" class="nx-btn"><i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Bal: 0.214 SOL</button>
    <button id="nx-profile" class="relative w-8 h-8 rounded-xl overflow-hidden border"
            style="border-color:var(--nx-border)">
      <img id="nx-pfp" src="NebulaX-logo.png" alt="" class="absolute inset-0 w-full h-full object-cover" />
    </button>
  </div>
</div>
</header>

    <div class="page-wrap">
      <main class="mt-3 grid grid-cols-1 lg:grid-cols-[1fr_360px] gap-3">
        <!-- LEFT: Overview + positions + history -->
        <section class="space-y-3">
          <div class="nx-panel p-3">
            <div class="grid grid-cols-2 md:grid-cols-4 gap-3 text-center">
              <div class="nx-panel p-3 tabnums"><div class="text-zinc-400 text-xs">Portfolio Value</div><div class="text-emerald-400 font-semibold">
  $<span id="pv-total-usd">0.00</span>
</div>
<div class="text-xs pos-cyan opacity-80">
  ≈ <span id="pv-total-sol">0.0000</span> SOL
</div>
</div>
              <div class="nx-panel p-3 tabnums"><div class="text-zinc-400 text-xs">Unrealized PnL</div><div id="pv-unrl" class="text-xl">$0 (0%)</div></div>
              <div class="nx-panel p-3 tabnums"><div class="text-zinc-400 text-xs">Realized PnL</div><div id="pv-rlzd" class="text-xl">$0</div></div>
              <div class="nx-panel p-3 tabnums"><div class="text-zinc-400 text-xs">Cash (SOL)</div><div id="pv-cash" class="text-xl pos-cyan">0.000</div><div class="text-xs opacity-80">
  $<span id="pv-cash-usd">0.00</span>
</div>
</div>
            </div>
          </div>

          <div class="nx-panel p-3">
            <div class="flex items-center justify-between mb-2">
              <div class="text-xl nx-title">Positions</div>
              <div class="flex gap-2">
                <!-- controls removed per request -->
              </div>
            </div>
            <div class="themed-scroll max-h-[420px] overflow-auto rounded-[12px] border border-[var(--nx-border)]">
              <table class="nx-table" id="pos-table">
                <thead>
                  <tr>
                    <th class="nx-th cursor-pointer hover:text-emerald-400" data-sort="token" title="Click to sort">Token ▾</th>
                    <th class="nx-th cursor-pointer hover:text-emerald-400" data-sort="qty" title="Click to sort">Qty ▾</th>
                    <th class="nx-th cursor-pointer hover:text-emerald-400" data-sort="avgCost" title="Click to sort">Avg Cost ▾</th>
                    <th class="nx-th cursor-pointer hover:text-emerald-400" data-sort="price" title="Click to sort">Price ▾</th>
                    <th class="nx-th cursor-pointer hover:text-emerald-400" data-sort="value" title="Click to sort">Value ▾</th>
                    <th class="nx-th cursor-pointer hover:text-emerald-400" data-sort="unrealized" title="Click to sort">Unrealized ▾</th>
                    <th class="nx-th cursor-pointer hover:text-emerald-400" data-sort="pct" title="Click to sort">% ▾</th>
                    <th class="nx-th">Actions</th>
                  </tr>
                </thead>
                <tbody id="pos-body"></tbody>
              </table>
            </div>
          </div>

          <div class="nx-panel p-3">
            <div class="flex items-center justify-between mb-2">
              <div class="text-xl nx-title">Trade Log (mock)</div>
              <div class="flex gap-2">
                <!-- Add Trade removed per request -->
                <button id="log-clear" class="nx-btn">Clear Log</button>
              </div>
            </div>
            <div class="themed-scroll max-h-[300px] overflow-auto rounded-[12px] border border-[var(--nx-border)]">
              <table class="nx-table" id="log-table">
                <thead>
                  <tr>
                    <th class="nx-th">Time</th>
                    <th class="nx-th">Token</th>
                    <th class="nx-th">Side</th>
                    <th class="nx-th">Qty</th>
                    <th class="nx-th">Price</th>
                    <th class="nx-th">Fee</th>
                    <th class="nx-th">Note</th>
                    <th class="nx-th">Actions</th>
                  </tr>
                </thead>
                <tbody id="log-body"></tbody>
              </table>
            </div>
          </div>
        </section>

        <!-- RIGHT: Price editor + summary -->
        <aside class="nx-panel p-3">
          <div class="nx-panel p-3 mb-3">
            <div class="text-sm font-semibold mb-2">Manual Price Editor</div>
            <div id="price-box" class="space-y-2 text-sm"></div>
            <button id="price-rand" class="nx-btn w-full mt-2">Nudge Prices (±5%)</button>
          </div>

          <div class="nx-panel p-3">
            <div class="text-sm font-semibold mb-2">Snapshot</div>
            <div id="snap-box" class="text-sm text-zinc-300">Add trades to see snapshot.</div>
          </div>
        </aside>
      </main>

      <footer class="mt-3 mb-4">
        <div class="nx-panel px-3 py-2 text-xs flex items-center justify-between">
          <div class="flex items-center gap-3">
            <span class="text-zinc-400">Status:</span>
            <span class="text-emerald-400">Idle (mock)</span>
          </div>
          <div>&copy; <span id="year"></span> NebulaX • Portfolio • Front-end mock</div>
        </div>
      </footer>
    </div>

    <!-- Wallet Modal Popup -->
    <div id="wallet-modal" class="modal-fx hidden">
      <div class="nx-panel w-[380px] max-w-[90vw] p-4">
        <div class="flex items-center justify-between mb-3">
          <div class="text-lg font-semibold">Wallet</div>
          <button class="nx-btn nx-btn-cyan px-2 py-1 text-xs" onclick="document.getElementById('wallet-modal').classList.add('hidden')">Close</button>
        </div>
        <div class="grid grid-cols-2 gap-2 text-sm mb-3">
          <div class="nx-panel p-3">
            <div class="text-xs text-zinc-400 mb-1">Total Balance</div>
            <div class="font-semibold text-base" id="wallet-total">0.000 SOL</div>
          </div>
          <div class="nx-panel p-3">
            <div class="text-xs text-zinc-400 mb-1">Available</div>
            <div class="font-semibold text-base" id="wallet-available">0.000 SOL</div>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-2 mb-3">
          <button id="wd-open" class="nx-btn">Withdraw</button>
          <button id="dp-open" class="nx-btn nx-btn-cyan">Deposit</button>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <button id="wallet-connect" class="nx-btn nx-btn-cyan">Connect</button>
          <button id="wallet-disconnect" class="nx-btn">Disconnect</button>
        </div>
      </div>
    </div>
    <div id="deposit" class="modal-fx hidden">
      <div class="nx-panel w-[360px] max-w-[90vw] p-3">
        <div class="flex items-center justify-between mb-2"><div class="font-semibold">Deposit</div><button class="nx-btn nx-btn-cyan px-2 py-1 text-xs" onclick="document.getElementById('deposit').classList.add('hidden')">Close</button></div>
        <div class="text-sm text-zinc-400 mb-2">Send SOL to your platform wallet address:</div>
        <div class="nx-panel p-2 text-xs break-words" id="deposit-addr">Do7AJiNrJvFVGTUCw8XvVhRGVBVLTHcBvEnfi3K68gze</div>
        <button class="nx-btn nx-btn-cyan w-full mt-3" id="copy-deposit-btn">Copy Address</button>
      </div>
    </div>
    <div id="withdraw" class="modal-fx hidden">
      <div class="nx-panel w-[360px] max-w-[90vw] p-3">
        <div class="flex items-center justify-between mb-2"><div class="font-semibold">Withdraw</div><button class="nx-btn nx-btn-cyan px-2 py-1 text-xs" onclick="document.getElementById('withdraw').classList.add('hidden')">Close</button></div>
        <div class="space-y-2">
          <input class="nx-input" placeholder="Destination SOL address"/>
          <div class="grid grid-cols-3 gap-2">
            <input class="nx-input col-span-2" placeholder="Amount"/>
            <select class="nx-input"><option>SOL</option><option>USD</option></select>
          </div>
          <button class="nx-btn nx-btn-cyan w-full">Submit</button>
        </div>
      </div>
    </div>

    <script>
      /* Icons + Year */
      if (window.lucide && typeof window.lucide.createIcons==='function'){ window.lucide.createIcons(); }
      document.getElementById('year').textContent = new Date().getFullYear();

      /* Back */
      document.getElementById('back-btn')?.addEventListener('click', (e)=>{ e.preventDefault(); history.back(); });

    </script>
    <!-- Search dropdown (Photon-style) -->
    <script>
      (function(){
        const data = [
          {id:'WIF', name:'dogwifhat', mc:'4.2B', vol:'118M', liq:'32.1M'},
          {id:'BONK', name:'Bonk', mc:'1.8B', vol:'88.0M', liq:'20.2M'},
          {id:'MEW', name:'MEW', mc:'420M', vol:'21.3M', liq:'6.7M'},
          {id:'POP', name:'POPCAT', mc:'310M', vol:'12.0M', liq:'4.9M'},
          {id:'CAT', name:'Cat', mc:'95M', vol:'9.4M', liq:'2.1M'},
          {id:'PENGU', name:'Pengu', mc:'180M', vol:'15.2M', liq:'3.2M'},
          {id:'DUCK', name:'Duck', mc:'42M', vol:'3.6M', liq:'1.1M'},
          {id:'PUP', name:'Pup', mc:'61M', vol:'5.4M', liq:'1.6M'},
          {id:'GME', name:'GameStop', mc:'720M', vol:'43.0M', liq:'12.9M'},
          {id:'PEPE', name:'PEPE', mc:'1.1B', vol:'98.2M', liq:'23.4M'},
          {id:'MOG', name:'MOG', mc:'250M', vol:'18.5M', liq:'5.8M'},
          {id:'BOME', name:'BOME', mc:'390M', vol:'22.1M', liq:'7.2M'}
        ];
        const input = document.getElementById('search-input');
        const dd = document.getElementById('search-dd');

        function itemTpl(x){
          return `<div class="result-item" data-id="${x.id}">
            <div class="ri-left"><i data-lucide="diamond" class="w-3 h-3 text-zinc-300"></i></div>
            <div class="ri-main">
              <div class="ri-pair">${x.id} / SOL</div>
              <div class="ri-name">${x.name}</div>
            </div>
            <div class="ri-metrics">
              <div><span class="lab">MC</span>$${x.mc}</div>
              <div><span class="lab">V</span>$${x.vol}</div>
              <div><span class="lab">L</span>$${x.liq}</div>
            </div>
          </div>`;
        }
        function render(list){
          if(!list || list.length===0){
            dd.innerHTML = '<div class="search-head">RESULTS</div><div class="text-xs text-zinc-400 p-3">No matches</div>';
            dd.classList.remove('hidden'); return;
          }
          dd.innerHTML = '<div class="search-head">RESULTS</div>' + list.slice(0,8).map(itemTpl).join('');
          dd.classList.remove('hidden');
          if (window.lucide && typeof window.lucide.createIcons==='function'){ window.lucide.createIcons({attrs:{}}); }
        }
        function filter(q){
          q=q.trim().toLowerCase();
          if(!q){ dd.classList.add('hidden'); return []; }
          return data.filter(x=> x.id.toLowerCase().includes(q) || x.name.toLowerCase().includes(q));
        }
        input?.addEventListener('input', ()=>{ render(filter(input.value)); });
        input?.addEventListener('focus', ()=>{ if(input.value){ render(filter(input.value)); } });
        document.addEventListener('click', (e)=>{ if(!e.target.closest('#search-wrap')) dd.classList.add('hidden'); });
        dd?.addEventListener('click', (e)=>{
          const it = e.target.closest('.result-item'); if(!it) return;
          const id = it.getAttribute('data-id');
          const el = document.getElementById('row-'+id);
          if(el){
            el.classList.add('highlight');
            el.scrollIntoView({behavior:'smooth',block:'center'});
            setTimeout(()=>el.classList.remove('highlight'), 1200);
          }
          dd.classList.add('hidden'); input.blur();
        });
        window.addEventListener('keydown', (e)=>{ if(e.key==='/' && document.activeElement!==input){ e.preventDefault(); input.focus(); }});
      })();


    </script>

<script type="module">
  
  // Use YOUR real key here:
  window.NX_RPC = 'https://mainnet.helius-rpc.com/?api-key=3858d764-530d-4b75-b3df-619dc2613ff9';
  try { localStorage.setItem('NX_RPC', window.NX_RPC); } catch {}
  
  function resolveRpc(){
  try{
    const s = String(window.NX_RPC || '').trim();
    // If it’s a Helius URL without a real key, or a placeholder, fall back
    if (/YOUR_KEY/i.test(s)) return 'https://api.mainnet-beta.solana.com';
    if (/helius/i.test(s) && !/api-key=/.test(s)) return 'https://api.mainnet-beta.solana.com';
    return s || 'https://api.mainnet-beta.solana.com';
  }catch{
    return 'https://api.mainnet-beta.solana.com';
  }
}

  /* ===== Wallet modal + modals ===== */
  const wBtn=document.getElementById('wallet-btn'); const wModal=document.getElementById('wallet-modal');
  
  // Update wallet display with real balance
  function updateWalletDisplay(){
    const balance = window.NXWallet?.getBalance?.();
    const sol = balance ? balance.toFixed(3) : '0.000';
    document.getElementById('wallet-total').textContent = sol + ' SOL';
    document.getElementById('wallet-available').textContent = sol + ' SOL';
  }
  
  wBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); updateWalletDisplay(); wModal.classList.remove('hidden'); });
  wModal?.addEventListener('click',(e)=>{ if(e.target===wModal) wModal.classList.add('hidden'); });
  document.getElementById('dp-open')?.addEventListener('click',()=>{ wModal.classList.add('hidden'); document.getElementById('deposit').classList.remove('hidden'); });
  document.getElementById('wd-open')?.addEventListener('click',()=>{ wModal.classList.add('hidden'); document.getElementById('withdraw').classList.remove('hidden'); });
  
  // Wallet connect/disconnect
  document.getElementById('wallet-connect')?.addEventListener('click',async()=>{ 
    const prov = (window.phantom?.solana) || window.solana;
    try { await prov?.connect?.(); } catch(e) { console.log('Connect cancelled'); }
  });
  document.getElementById('wallet-disconnect')?.addEventListener('click',async()=>{ 
    const prov = (window.phantom?.solana) || window.solana;
    try { await prov?.disconnect?.(); } catch(e) { console.log('Disconnect error'); }
  });
  
  // Deposit address copy
  const copyBtn = document.getElementById('copy-deposit-btn');
  const depositAddr = document.getElementById('deposit-addr');
  copyBtn?.addEventListener('click',()=>{ 
    const addr = depositAddr.textContent;
    navigator.clipboard.writeText(addr).then(()=>{ copyBtn.textContent='Copied!'; setTimeout(()=>{ copyBtn.textContent='Copy Address'; },2000); }); 
  });
  
  // Close modals on click outside
  document.getElementById('deposit')?.addEventListener('click',(e)=>{ if(e.target.id==='deposit') e.target.classList.add('hidden'); });
  document.getElementById('withdraw')?.addEventListener('click',(e)=>{ if(e.target.id==='withdraw') e.target.classList.add('hidden'); });
  
  // Listen for balance changes
  window.addEventListener('nebula:sol:changed',(e)=>{ if(!wModal.classList.contains('hidden')) updateWalletDisplay(); });

  /* ===== LIVE Portfolio state (replaces mock) ===== */
  import { Connection, PublicKey } from "https://esm.sh/@solana/web3.js@1.95.3";

  // Config
const NX_RPC = resolveRpc();
const connection = new Connection(NX_RPC, "confirmed");
  const WRAPPED_SOL = "So11111111111111111111111111111111111111112";
  const JUP_TOKENS_URL = "https://tokens.jup.ag/tokens?tags=verified";
  const JUP_PRICE_URL = "https://price.jup.ag/v6/price?ids="; // append comma-separated mints

  // UI handles (existing IDs)
  const posBody=document.getElementById('pos-body');
  const logBody=document.getElementById('log-body');
  const pvTotalUsd=document.getElementById('pv-total-usd');
  const pvTotalSol=document.getElementById('pv-total-sol');
  const pvUnrl=document.getElementById('pv-unrl');
  const pvRlz=document.getElementById('pv-rlzd');
  const pvCash=document.getElementById('pv-cash');
  const pvCashUsd=document.getElementById('pv-cash-usd');
  const priceBox=document.getElementById('price-box');
  const snapBox=document.getElementById('snap-box');

  // Keys (needed before load/save)
  const POS_KEY = 'nebula_positions_v1';
  const LOG_KEY = 'nebula_trades_v1';
  const RLZ_KEY = 'nebula_realized_v1';


  function load(key, fb){ try{ return JSON.parse(localStorage.getItem(key)) ?? fb; }catch{return fb;} }
  function save(key, val){ localStorage.setItem(key, JSON.stringify(val)); }

  // Runtime state - load from localStorage to persist trades
 let POS = {};   // start clean; we'll overwrite with live SPL balances
 let LOG = load(LOG_KEY, []);   // load saved trade history
 let RLZ = load(RLZ_KEY, 0);   // load saved realized PnL
  let META = new Map();          // mint -> token metadata from Jupiter
  let PRICES = {};               // mint -> price in USD
  let SOL_BAL = 0;               // SOL balance numeric
let SOL_PRICE = 0; // <-- new: current SOL/USD

  /* ---------- Helpers ---------- */
  function fmtUSD(n){
    if(!isFinite(n)) return '$0';
    const sign=n<0?'-':''; n=Math.abs(n);
    if(n>=1_000_000_000) return sign+'$'+(n/1_000_000_000).toFixed(2)+'B';
    if(n>=1_000_000) return sign+'$'+(n/1_000_000).toFixed(2)+'M';
    if(n>=1_000) return sign+'$'+(n/1_000).toFixed(2)+'K';
    return sign+'$'+n.toFixed(2);
  }

  async function getTokenList(){
    const CACHE_KEY = "nx_jup_tokens_cache_v1";
    const TTL_MS = 24*60*60*1000;
    try{
      const cached = JSON.parse(localStorage.getItem(CACHE_KEY)||"null");
      if (cached && Date.now()-cached.time < TTL_MS) return cached.data;
    }catch{}
    try {
      const res = await fetch(JUP_TOKENS_URL, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      localStorage.setItem(CACHE_KEY, JSON.stringify({ time: Date.now(), data }));
      return data;
    } catch(e) {
      console.warn('[Portfolio] Token list fetch failed, using empty list:', e);
      return [];
    }
  }

  async function getPricesV6(mints){
    if(!mints.length) return {};
    const uniq=[...new Set(mints)];
    const chunk=(arr,n)=>arr.reduce((a,_,i)=>i%n? a : [...a,arr.slice(i,i+n)],[]);
    const out = {};
    for (const group of chunk(uniq, 180)){
      try {
        const url = JUP_PRICE_URL + encodeURIComponent(group.join(","));
        const r = await fetch(url);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const j = await r.json();
        for (const [mint, obj] of Object.entries(j?.data||{})){
          out[mint] = Number(obj?.price || 0);
        }
      } catch(e) {
        console.warn('[Portfolio] Price fetch failed for batch:', e);
        // Set prices to 0 for failed mints
        for (const mint of group) {
          if (!(mint in out)) out[mint] = 0;
        }
      }
    }
    return out;
  }

  async function getSOLBalance(pubkey){
    const lamports = await connection.getBalance(pubkey, "confirmed");
    return lamports / 1_000_000_000;
  }

  async function getSPLAccounts(pubkey){
    const resp = await connection.getParsedTokenAccountsByOwner(
      pubkey,
      { programId: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA") },
      "confirmed"
    );
    return resp.value
      .map(v => v.account?.data?.parsed?.info)
      .filter(Boolean)
      .map(info => ({
        mint: info.mint,
        uiAmount: Number(info.tokenAmount?.uiAmount || 0),
        decimals: Number(info.tokenAmount?.decimals || 0),
      }))
      .filter(t => t.uiAmount > 0);
  }

  function symbolForMint(mint){
    const m = META.get(mint);
    return m?.symbol || (mint.slice(0,6)+'…'+mint.slice(-4));
  }
  function nameForMint(mint){
    const m = META.get(mint);
    return m?.name || 'SPL Token';
  }

function recalc(){
  // Calculate SPL token value and unrealized PnL
  let splValue = 0;
  let unrealizedTotal = 0;
  
  Object.values(POS).forEach(p => {
    const currentValue = (p.qty || 0) * (p.price || 0);
    splValue += currentValue;
    const costBasis = (p.qty || 0) * (p.avg || p.price || 0);
    unrealizedTotal += (currentValue - costBasis);
  });
  
  // Total portfolio value = SOL + SPL tokens
  const solValue = (SOL_BAL || 0) * (SOL_PRICE || 0);
  const totalUSD = solValue + splValue;
  const totalSOL = SOL_PRICE > 0 ? (totalUSD / SOL_PRICE) : 0;

  // Portfolio Value (USD + SOL equivalent)
  if(pvTotalUsd) pvTotalUsd.textContent = fmtUSD(totalUSD).replace('$','');
  if(pvTotalSol) pvTotalSol.textContent = totalSOL.toFixed(4);

  // Unrealized PnL
  if(pvUnrl) {
    const pct = splValue > 0 ? ((unrealizedTotal / (splValue - unrealizedTotal)) * 100) : 0;
    pvUnrl.textContent = `${fmtUSD(unrealizedTotal)} (${pct >= 0 ? '+' : ''}${pct.toFixed(1)}%)`;
    pvUnrl.classList.remove('pos-green','pos-red');
    pvUnrl.classList.add(unrealizedTotal >= 0 ? 'pos-green' : 'pos-red');
  }

  // Realized PnL
  if(pvRlz) {
    pvRlz.textContent = fmtUSD(RLZ || 0);
    pvRlz.classList.remove('pos-green','pos-red');
    if(RLZ !== 0) pvRlz.classList.add(RLZ >= 0 ? 'pos-green' : 'pos-red');
  }

  // Cash (SOL)
  if(pvCash) pvCash.textContent = (SOL_BAL||0).toFixed(3);
  if(pvCashUsd) pvCashUsd.textContent = fmtUSD(solValue).replace('$','');

  // Draw positions and sidebar
  drawPositions();
  drawPrices();
  
  // Snapshot
  if(snapBox) {
    const posCount = Object.keys(POS).length;
    snapBox.textContent = posCount > 0 
      ? `${posCount} active position${posCount > 1 ? 's' : ''} • ${new Date().toLocaleTimeString()}`
      : 'No positions. Connect wallet to view holdings.';
  }
}


  function drawPositions(){
    posBody.innerHTML='';
    Object.entries(POS).forEach(([sym,p])=>{
      const val=(p.qty||0)*(p.price||0);
      const unrl=(p.price - (p.avg||p.price))*(p.qty||0); // ~0 by default
      const pct = (p.avg ? ((p.price/p.avg)-1)*100 : 0);
      const tr=document.createElement('tr'); tr.id = `row-${sym}`;
      tr.style.cursor = 'pointer'; // Make it clear the row is clickable
      tr.innerHTML=`
        <td class="nx-td"><strong>${sym}</strong></td>
        <td class="nx-td tabnums">${(p.qty||0).toLocaleString()}</td>
        <td class="nx-td tabnums">$${(p.avg||0).toFixed(6)}</td>
        <td class="nx-td tabnums">
          <input data-tok="${sym}" data-k="price" type="number" step="0.000001" class="nx-input tabnums" value="${(p.price||0).toFixed(6)}"/>
        </td>
        <td class="nx-td tabnums">${fmtUSD(val)}</td>
        <td class="nx-td tabnums ${unrl>=0?'pos-green':'pos-red'}">${fmtUSD(unrl)}</td>
        <td class="nx-td tabnums ${pct>=0?'pos-green':'pos-red'}">${pct.toFixed(2)}%</td>
        <td class="nx-td" style="display:flex; gap:6px;">
          <button class="nx-btn" data-act="sell" data-tok="${sym}">Sell</button>
          <button class="nx-btn" data-act="del" data-tok="${sym}">Remove</button>
        </td>`;
      posBody.appendChild(tr);
    });
  }

  posBody.addEventListener('input',(e)=>{
    const inp=e.target.closest('input[data-tok]'); if(!inp) return;
    const t=inp.getAttribute('data-tok'); const k=inp.getAttribute('data-k');
    const v=parseFloat(inp.value)||0; if(!POS[t]) return;
    POS[t][k]=v; save(POS_KEY, POS); recalc();
  });

  posBody.addEventListener('click',(e)=>{
    // Check if clicking on a button first (Sell/Remove)
    const btn=e.target.closest('button[data-act]');
    if(btn){
      const t=btn.getAttribute('data-tok');
      if(btn.getAttribute('data-act')==='del'){ delete POS[t]; save(POS_KEY, POS); recalc(); return; }
      if(btn.getAttribute('data-act')==='sell'){
        const qty=parseFloat(prompt('Sell quantity:', (POS[t]?.qty||0))); if(!qty) return;
        const price=parseFloat(prompt('Sell price:', (POS[t]?.price||0))); if(!price) return;
        const fee=0.001; // placeholder
        const p=POS[t]||{qty:0,avg:POS[t]?.price||0,price};
        const realized = (price - (p.avg||price)) * Math.min(qty, p.qty||0);
        RLZ += realized - fee;
        p.qty = Math.max(0, (p.qty||0) - qty);
        if(p.qty===0){ delete POS[t]; } else { POS[t]=p; }
        LOG.push({ts:Date.now(), token:t, side:'SELL', qty, price, fee, note:'manual'});
        save(POS_KEY, POS); save(LOG_KEY, LOG); save(RLZ_KEY, RLZ);
        recalc(); renderLog();
      }
      return; // Don't navigate if clicking buttons
    }
    
    // Check if clicking on input field
    const inp=e.target.closest('input[data-tok]');
    if(inp) return; // Don't navigate if clicking input
    
    // Otherwise, clicking anywhere on the row navigates to coin page
    const row = e.target.closest('tr');
    if(!row || !row.id) return;
    
    const sym = row.id.replace('row-', '');
    const posData = POS[sym];
    console.log('[Portfolio] Clicked row for token:', sym, 'POS data:', posData);
    
    if (posData && posData.mint) {
      const coinData = { 
        symbol: sym, 
        mint: posData.mint, 
        pair: sym.includes('/') ? sym : (sym + '/SOL') 
      };
      console.log('[Portfolio] Navigating with:', coinData);
      NX.goToCoin(coinData);
    } else {
      const pair = sym.includes('/') ? sym : (sym + '/SOL');
      console.warn('[Portfolio] No mint found for', sym, '- using pair only. POS:', POS);
      NX.goToCoin({ pair });
    }
  });

  function drawPrices(){
    priceBox.innerHTML='';
    Object.entries(POS).forEach(([t,p])=>{
      const row=document.createElement('div'); row.className='grid grid-cols-3 gap-2 items-center';
      row.innerHTML=`<div>${t}</div><input data-tok="${t}" data-k="price" type="number" step="0.000001" class="nx-input tabnums" value="${(p.price||0).toFixed(6)}"/><div class="text-right tabnums">${fmtUSD((p.qty||0)*(p.price||0))}</div>`;
      priceBox.appendChild(row);
    });
  }
  priceBox.addEventListener('input',(e)=>{
    const inp=e.target.closest('input[data-tok]'); if(!inp) return;
    const t=inp.getAttribute('data-tok'); const v=parseFloat(inp.value)||0; if(!POS[t]) return; POS[t].price=v; save(POS_KEY, POS); recalc();
  });

  // “Nudge Prices” -> refresh live prices
  document.getElementById('price-rand')?.addEventListener('click', async ()=>{
    await refreshLive(true);
  });

  function renderLog(){
    logBody.innerHTML='';
    if (!LOG.length){
      logBody.innerHTML = `<tr><td class="nx-td text-zinc-400" colspan="8">No trades yet.</td></tr>`;
      return;
    }
    LOG.slice().reverse().forEach((r,i)=>{
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td class="nx-td">${new Date(r.ts).toLocaleString()}</td>
        <td class="nx-td">${r.token}</td>
        <td class="nx-td">${r.side}</td>
        <td class="nx-td tabnums">${r.qty}</td>
        <td class="nx-td tabnums">$${r.price}</td>
        <td class="nx-td tabnums">${r.fee}</td>
        <td class="nx-td">${r.note||''}</td>
        <td class="nx-td"><button class="nx-btn" data-i="${LOG.length-1-i}">Delete</button></td>`;
      logBody.appendChild(tr);
    });
  }
  logBody.addEventListener('click',(e)=>{
    const btn=e.target.closest('button[data-i]'); if(!btn) return;
    const idx=parseInt(btn.getAttribute('data-i')); LOG.splice(idx,1); save(LOG_KEY, LOG); renderLog();
  });
  document.getElementById('log-clear')?.addEventListener('click',()=>{ if(!confirm('Clear trade log?')) return; LOG=[]; save(LOG_KEY, LOG); renderLog(); });

  function drawSnapshot(){
    const parts = Object.entries(POS).map(([t,p])=> ({t, v:(p.qty||0)*(p.price||0)}));
    const total = parts.reduce((a,b)=>a+b.v,0);
    if(total<=0){ snapBox.textContent='Add trades to see snapshot.'; return; }
    parts.sort((a,b)=>b.v-a.v);
    snapBox.innerHTML = parts.map(x=>`<div class='flex justify-between'><span>${x.t}</span><span class='tabnums'>${fmtUSD(x.v)}</span></div>`).join('') +
      `<div class='mt-2 flex justify-between border-t border-[var(--nx-border)] pt-1'><strong>Total</strong><strong class='tabnums'>${fmtUSD(total)}</strong></div>`;
  }

  /* ---------- Live loading pipeline ---------- */
  async function refreshLive(onlyPrices=false){
    try{
      const w = window.NXWallet;
      if (!w?.isConnected?.()) return;

      const addr = w.getAddress?.();
      if (!addr) return;

      const pubkey = new PublicKey(addr);

      // 1) Metadata cache
      const tokens = await getTokenList();
      META = new Map(tokens.map(t=>[t.address, t]));

      // 2) Balances
      SOL_BAL = await getSOLBalance(pubkey);
      // write SOL balance on header button (existing text)
  const btn = document.getElementById('wallet-btn');
  if (btn) {
    btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Available: ${SOL_BAL.toFixed(3)} SOL`;
    try { window.lucide?.createIcons?.(); } catch {}
  }


      let spl = [];
      if (!onlyPrices){
        spl = await getSPLAccounts(pubkey);
      } else {
        // Reuse existing POS mints to refresh prices
        spl = Object.values(POS).map(p=>({ mint: p.mint, uiAmount: p.qty }));
      }

      // 3) Prices
      const mints = [WRAPPED_SOL, ...spl.map(t=>t.mint)];
      PRICES = await getPricesV6(mints);
      SOL_PRICE = PRICES[WRAPPED_SOL] || 0; 

      // 4) Map into your POS shape (symbol keyed)
      if (!onlyPrices){
        const nextPOS = {};
        for (const a of spl){
          const meta = META.get(a.mint);
          const sym = (meta?.symbol || (a.mint.slice(0,6)+'…'+a.mint.slice(-4))).toUpperCase();
          const price = PRICES[a.mint] || 0;
          // avg := price for now (no PnL). Replace later with your cost basis if/when available.
          nextPOS[sym] = { qty: a.uiAmount, avg: price, price, mint: a.mint };
        }
        POS = nextPOS;
        save(POS_KEY, POS);
      } else {
        // Update prices only
        for (const [sym,p] of Object.entries(POS)){
          POS[sym].price = PRICES[p.mint] || p.price || 0;
        }
        save(POS_KEY, POS);
      }

      // 5) Recalc UI (SOL value included in totals via snapshot/positions sum—positions are SPL only; SOL shows in Cash)
      recalc();
    }catch(e){
      console.error("Live refresh failed", e);
    }
  }

  // OLD Boot: DISABLED - using recompute() system instead
  /*
  async function boot(){
    renderLog();
    if (window.NXWallet?.isConnected?.()){
      await refreshLive(false);
    }
  }
  boot();
  */

  // OLD Wallet events: DISABLED - using recompute() system instead
  /*
  /*
  window.addEventListener("nxwallet:connected", () => refreshLive(false));
  window.addEventListener("nxwallet:disconnected", () => {
    POS = {}; SOL_BAL = 0; PRICES = {}; save(POS_KEY, POS);
    recalc(); // clears UI
    if (wBtn) wBtn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Bal: 0.000 SOL`;
    try{ window.lucide?.createIcons?.(); }catch{}
  });

  // Light periodic refresh of prices only (no Helius burn, just Jupiter price API)
  // Feel free to remove if you want strictly manual refresh.
  setInterval(()=>{ if (window.NXWallet?.isConnected?.()) refreshLive(true); }, 60_000);

  // Initial draw (empty until wallet connects / loads)
  recalc();
  */
</script>

<script>
/** ===== NebulaX Click-to-Coin Utilities ===== */
window.NX = window.NX || {};
NX.saveSelectedCoin = function(coin){
  console.log('[Portfolio] Saving to localStorage:', coin);
  try { localStorage.setItem('nebula_selected_coin', JSON.stringify(coin)); } catch(e){}
};
NX.goToCoin = function(coin){
  console.log('[Portfolio] goToCoin called with:', coin);
  NX.saveSelectedCoin(coin);
  const pair = coin.pair || (coin.symbol ? (coin.symbol.toUpperCase()+'/SOL') : '');
  const mint = encodeURIComponent(coin.mint || '');
  const qp = `?pair=${encodeURIComponent(pair)}${mint ? `&mint=${mint}` : ''}`;
  console.log('[Portfolio] Navigating to:', `Coinpage-Official.html${qp}`);
  location.href = `Coinpage-Official.html${pair ? qp : ''}`;
};
</script>
<script>
/* === NebulaX Core (themes, header hydrate, routing hooks) === */
(function(){
  const UserStore={
    key:'nx_user',
    state:{ wallet:null, theme:'default', pfp:{type:'builtin',url:'/pfp/default.png'} },
    load(){ try{ Object.assign(this.state, JSON.parse(localStorage.getItem(this.key)||'{}')); }catch{} },
    save(){ localStorage.setItem(this.key, JSON.stringify(this.state)); }
  };
  UserStore.load();

  const Theme={
    init(){
      const t = UserStore.state.theme || 'default';
      document.documentElement.setAttribute('data-theme', t);
      const sel = document.getElementById('nx-theme');
      if (sel) sel.value = t;
      sel?.addEventListener('change', (e)=>{
        const v=e.target.value;
        document.documentElement.setAttribute('data-theme', v);
        UserStore.state.theme=v; UserStore.save();
      });
    }
  };

  const Header={
    initActiveTab(){
      const here = location.pathname.replace(/\/+$/,'') || '/NebulaX.html';
      document.querySelectorAll('.nx-tab').forEach(a=>{
        const route = a.getAttribute('data-route');
        if (!route) return;
        if (route===here) a.classList.add('active');
        else a.classList.remove('active');
        a.addEventListener('click',(e)=>{
          // allow normal navigation
        });
      });
    },
    initSearch(){
      const input = document.getElementById('nx-search');
      const btn   = document.getElementById('nx-search-btn');
      if(!input||!btn) return;
      const go = ()=>{
        const q = (input.value||'').trim();
        if(!q) return;
        // Route to coin page convention: /Coinpage-Official.html?query=...
        location.href = `/Coinpage-Official.html?query=${encodeURIComponent(q)}`;
      };
      btn.addEventListener('click', go);
      input.addEventListener('keydown', (e)=>{ if(e.key==='Enter') go(); });
    },
    initPfp(){
      const img = document.getElementById('nx-pfp');
      if(img) img.src = (UserStore.state.pfp?.url)||'/pfp/default.png';
      const btn = document.getElementById('nx-profile');
      btn?.addEventListener('click',()=>{
        // simple MVP: cycle built-ins; later open profile modal
        const choices=['/pfp/default.png','/pfp/nx01.png','/pfp/nx02.png'];
        const idx = Math.max(0, choices.indexOf(UserStore.state.pfp?.url));
        const next = choices[(idx+1)%choices.length];
        UserStore.state.pfp={type:'builtin',url:next}; UserStore.save();
        if(img) img.src=next;
      });
    },
    initStore(){
      const a = document.getElementById('nx-store');
      if(!a) return;
      // keep as a link; if you make a modal later, hydrate here
    },
    initWallet(){
      const w = document.getElementById('nx-wallet');
      w?.addEventListener('click', ()=>{
        // hook your wallet adapter here
        alert('Connect wallet (hook your adapter)');
      });
    },
    mount(){ this.initActiveTab(); this.initSearch(); this.initPfp(); this.initStore(); this.initWallet(); }
  };

  document.addEventListener('DOMContentLoaded', ()=>{
    Theme.init();
    Header.mount();
  });
})();
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("wallet-btn");

  function updateWalletBtn() {
    const bal = window.NXWallet?.getBalance?.();
    if (bal != null) {
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> ${bal.toFixed(3)} SOL`;
    } else {
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Connect Wallet`;
    }
    try { window.lucide?.createIcons?.(); } catch {}
  }

  // Initial state
  updateWalletBtn();

  // Subscribe to NXWallet events
  window.addEventListener("nebula:sol:changed", updateWalletBtn);
});
</script>
<script>
document.addEventListener("DOMContentLoaded", async () => {
  const btn  = document.getElementById("wallet-btn");
  const cash = document.getElementById("pv-cash"); // the Cash (SOL) tile

  function paint(sol){
    if (!btn) return;
    if (sol == null) {
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Connect Wallet`;
    } else {
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Available: ${sol.toFixed(3)} SOL`;
      if (cash) cash.textContent = sol.toFixed(3); // keep the tile in sync too
    }
    try { window.lucide?.createIcons?.(); } catch {}
  }

  // 1) If NXWallet is already connected (same session as Home), show balance
  if (window.NXWallet?.isConnected?.()) {
    try { await window.NXWallet.refreshBalance?.(true); } catch {}
    const bal = window.NXWallet?.getBalance?.();
    paint(bal);
  } else {
    // 2) Try a trust-only reconnect (no popup) to reattach the same Phantom session
    const prov = (window.phantom?.solana) || window.solana;
    try { await prov?.connect?.({ onlyIfTrusted: true }); } catch {}
    if (window.NXWallet?.isConnected?.()) {
      try { await window.NXWallet.refreshBalance?.(true); } catch {}
      const bal = window.NXWallet?.getBalance?.();
      paint(bal);
    } else {
      paint(null);
    }
  }

  // 3) Stay updated whenever wallet emits changes (same events Home uses)
  window.addEventListener("nebula:sol:changed", (e)=> paint(e.detail?.balance));
  window.addEventListener("nxwallet:connected", async ()=>{
    try { await window.NXWallet.refreshBalance?.(true); } catch {}
    paint(window.NXWallet?.getBalance?.());
  });
  window.addEventListener("nxwallet:disconnected", ()=> paint(null));
});
</script>
<script type="module">
import { Connection, PublicKey, LAMPORTS_PER_SOL } from "https://esm.sh/@solana/web3.js@1.95.3";

// drop-in guard copied from nx-wallet
function resolveRpc(){
  try{
    const s = String(window.NX_RPC || '').trim();
    // If it’s a Helius URL without a real key, or a placeholder, fall back
    if (/YOUR_KEY/i.test(s)) return 'https://api.mainnet-beta.solana.com';
    if (/helius/i.test(s) && !/api-key=/.test(s)) return 'https://api.mainnet-beta.solana.com';
    return s || 'https://api.mainnet-beta.solana.com';
  }catch{
    return 'https://api.mainnet-beta.solana.com';
  }
}


const btn  = document.getElementById("wallet-btn");
const cash = document.getElementById("pv-cash");
const rpc  = resolveRpc(); // <- use guard here

function paint(sol){ /* ...unchanged... */ }

  

(async () => {
  if (window.NXWallet?.isConnected?.()) {
    try { await window.NXWallet.refreshBalance?.(true); } catch {}
    paint(window.NXWallet?.getBalance?.());
  } else {
    const prov = (window.phantom?.solana) || window.solana;
    try { await prov?.connect?.({ onlyIfTrusted: true }); } catch {}
    const pk = prov?.publicKey?.toString?.();
    if (pk) {
      const conn = new Connection(rpc, "confirmed");
      const lam  = await conn.getBalance(new PublicKey(pk));
      paint(lam / LAMPORTS_PER_SOL);
    } else {
      paint(null);
    }
  }
})();
</script>

<script>
(async () => {
  // 0) Quick env dump
  const info = {
    page: 'Portfolio',
    hasWeb3IIFE: !!window.solanaWeb3,
    hasNXWallet: !!window.NXWallet,
    NX_RPC: window.NX_RPC || '(missing)',
    origin: location.origin
  };
  console.table(info);

  // 1) Verify the wallet bundle REALLY loaded here
  if (!window.NXWallet) {
    console.error('[NX] nx-wallet.js is not available on this page. Check the path from THIS file to assets/nx-wallet.js.');
    try {
      const probe = await fetch('assets/nx-wallet.js', { method: 'HEAD', cache: 'no-store' });
      console.log('[NX] HEAD assets/nx-wallet.js →', probe.status, probe.ok);
    } catch (e) {
      console.warn('[NX] HEAD assets/nx-wallet.js failed:', e);
    }
  }

  const btn  = document.getElementById('wallet-btn');
  const cash = document.getElementById('pv-cash');

  function paint(sol){
    if (!btn) return;
    if (sol == null) {
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Connect Wallet`;
    } else {
      const s = (+sol).toFixed(3);
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Available: ${s} SOL`;
      if (cash) cash.textContent = s;
    }
    try { window.lucide?.createIcons?.(); } catch {}
  }

  // 2) If NXWallet is present, try the normal (trusted) path
  if (window.NXWallet) {
    try {
      // silently reattach if already trusted on THIS origin
      const prov = (window.phantom?.solana) || window.solana;
      try { await prov?.connect?.({ onlyIfTrusted: true }); } catch {}
      if (window.NXWallet.isConnected?.()) {
        await window.NXWallet.refreshBalance?.(true);
        paint(window.NXWallet.getBalance?.());
        console.log('[NX] painted from NXWallet (trusted connect).');
      } else {
        paint(null);
        console.warn('[NX] Not trusted on this origin yet. Click the wallet to connect here once.');
      }
    } catch (e) {
      console.warn('[NX] NXWallet refresh failed:', e);
    }

    // ensure we repaint when the wallet broadcasts
    window.addEventListener('nebula:sol:changed', (e) => {
      console.log('[NX] event nebula:sol:changed →', e.detail);
      paint(e.detail?.balance);
    });
  }

  // 3) Absolute fallback (works even if NXWallet didn’t bootstrap)
  if (!window.NXWallet || !window.NXWallet.isConnected?.()) {
    try {
      if (!window.solanaWeb3) throw new Error('No solanaWeb3 global.');
      const prov = (window.phantom?.solana) || window.solana;
      if (!prov) throw new Error('No Phantom provider available.');
      // Try trusted connect; if that yields a publicKey, read balance directly.
      try { await prov.connect({ onlyIfTrusted: true }); } catch {}
      const key = prov?.publicKey?.toString?.();
      if (key) {
        const url = (window.NX_RPC && window.NX_RPC.trim()) || 'https://api.mainnet-beta.solana.com';
        const conn = new solanaWeb3.Connection(url, 'confirmed');
        const lam  = await conn.getBalance(new solanaWeb3.PublicKey(key));
        const sol  = lam / solanaWeb3.LAMPORTS_PER_SOL;
        console.log('[NX] Fallback balance read OK:', sol);
        paint(sol);
        // Also broadcast so the rest of your page logic (and tiles) hear it
        window.dispatchEvent(new CustomEvent('nebula:sol:changed', { detail: { balance: sol }}));
      } else {
        console.warn('[NX] Fallback: still no publicKey (not trusted on this origin).');
      }
    } catch (e) {
      console.warn('[NX] Fallback balance probe failed:', e);
    }
  }

  // 4) Make the Connect button actually connect via NXWallet on this page
  btn?.addEventListener('click', async () => {
    try {
      await window.NXWallet?.connect?.();
      await window.NXWallet?.refreshBalance?.(true);
      paint(window.NXWallet?.getBalance?.());
      console.log('[NX] Connected via button, balance painted.');
    } catch (e) {
      console.error('[NX] Connect failed:', e);
    }
  });
})();
</script>
<script>
/* ===== NebulaX Portfolio Totals (robust autodetect) ===== */
const SOL_MINT = 'So11111111111111111111111111111111111111112';
const KNOWN_KEYS = ['nebula_positions_v1','nebula_trades_v1','nebula_open_positions','nebula_open_trades'];
const ID_CANDIDATES = {
  cashSol: ['pv-cash','cash-sol','nx-cash-sol'],
  cashUsd: ['pv-cash-usd','cash-usd','nx-cash-usd'],
  totSol : ['pv-total-sol','total-sol','nx-total-sol'],
  totUsd : ['pv-total-usd','total-usd','nx-total-usd'],
  posSol : ['pv-trades-sol','positions-sol','nx-positions-sol'],
  posUsd : ['pv-trades-usd','positions-usd','nx-positions-usd']
};

function $(id){ return document.getElementById(id); }
function firstEl(ids){ for (const id of ids) { const el = $(id); if (el) return el; } return null; }

let SOL_BAL = +window.NXWallet?.getBalance?.() || 0;
let LAST_SOL_USD = null;

function normalizePosition(p){
  // Try the usual field names we’ve seen across your files
  const mint = p.mint || p.tokenMint || p.baseMint || p.address || null;
  const qty  = +(
    p.qty ?? p.amount ?? p.baseAmount ?? p.size ?? p.qtyBase ?? 0
  );
  const closed = (p.closed || p.status === 'closed' || p.isClosed === true);
  return (mint && qty > 0 && !closed) ? { mint, qty } : null;
}

function readActivePositions(){
  const acc = [];
  for (const key of KNOWN_KEYS) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) continue;
      const data = JSON.parse(raw);
      const arr = Array.isArray(data) ? data : (Array.isArray(data?.items) ? data.items : []);
      for (const itm of arr) {
        const nx = normalizePosition(itm);
        if (nx) acc.push(nx);
      }
    } catch {}
  }
  // de-dup adjacent duplicates (same mint+qty)
  const uniq = [];
  const seen = new Set();
  for (const p of acc) {
    const k = p.mint+'|'+p.qty;
    if (!seen.has(k)) { uniq.push(p); seen.add(k); }
  }
  return uniq;
}

async function getPrices(mints){
  // Jupiter Lite V3 (CORS-safe, no key)
  const url = 'https://lite-api.jup.ag/price/v3?ids=' + encodeURIComponent(mints.join(','));
  try {
    const r = await fetch(url, { cache:'no-store' });
    if (!r.ok) throw new Error('HTTP '+r.status);
    return await r.json(); // {mint: {usdPrice, decimals, blockId, ...}}
  } catch (e) {
    console.warn('[PV] price fetch failed →', e);
    // return nulls
    const out = {}; mints.forEach(m=>out[m]=null); return out;
  }
}

function paintCash(solUsd){
  const cashSolEl = firstEl(ID_CANDIDATES.cashSol);
  const cashUsdEl = firstEl(ID_CANDIDATES.cashUsd);
  const btn       = document.getElementById('wallet-btn');
  const s = (SOL_BAL||0).toFixed(3);
  if (btn)       btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Available: ${s} SOL`;
  if (cashSolEl) cashSolEl.textContent = s;
  if (cashUsdEl && solUsd!=null) cashUsdEl.textContent = (SOL_BAL*solUsd).toFixed(2);
  try{ window.lucide?.createIcons?.(); }catch{}
}

function paintTotals({tradesUsd, solUsd}){
  const totUsdEl = firstEl(ID_CANDIDATES.totUsd);
  const totSolEl = firstEl(ID_CANDIDATES.totSol);
  const posUsdEl = firstEl(ID_CANDIDATES.posUsd);
  const posSolEl = firstEl(ID_CANDIDATES.posSol);

  const cashUsd  = solUsd ? SOL_BAL*solUsd : 0;
  const totalsUsd = (tradesUsd||0) + cashUsd;
  const totalsSol = solUsd ? (totalsUsd/solUsd) : (SOL_BAL||0);

  if (totUsdEl) totUsdEl.textContent = totalsUsd.toFixed(2);
  if (totSolEl) totSolEl.textContent = totalsSol.toFixed(3);
  if (posUsdEl) posUsdEl.textContent = (tradesUsd||0).toFixed(2);
  if (posSolEl) posSolEl.textContent = (solUsd ? (tradesUsd/solUsd) : 0).toFixed(3);
}

/** Read SPL token holdings from the connected wallet (excludes native SOL) */
async function readHoldingsFromWallet() {
  // Try NXWallet first, then fallback to standard providers
  let pubkeyStr = null;
  
  if (window.NXWallet?.isConnected?.()) {
    pubkeyStr = window.NXWallet.getAddress?.();
  } else {
    const prov = window.phantom?.solana || window.solana;
    pubkeyStr = prov?.publicKey?.toString();
  }
  
  if (!pubkeyStr) {
    console.warn('[Portfolio] No wallet address available');
    return [];
  }
  
  try {
    const pubkey = new solanaWeb3.PublicKey(pubkeyStr);
    const conn = new solanaWeb3.Connection((window.NX_RPC||'https://api.mainnet-beta.solana.com'),'confirmed');

    const resp = await conn.getParsedTokenAccountsByOwner(pubkey, { 
      programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') 
    });
    
    const out = [];
    for (const { account } of resp.value) {
      const info = account?.data?.parsed?.info;
      const mint = info?.mint;
      const amt = info?.tokenAmount;
      const ui = Number(amt?.uiAmount);
      // filter dust; adjust threshold to taste
      if (mint && isFinite(ui) && ui > 0) {
        out.push({ mint, qty: ui });
      }
    }
    console.log(`[Portfolio] Found ${out.length} SPL token holdings`);
    return out;
  } catch(e) {
    console.error('[Portfolio] Error reading wallet holdings:', e);
    return [];
  }
}

/** Combine: (localStorage positions) + (wallet holdings) and de-dup by mint summing qty */
async function getAllPositions() {
  const fromLocal = readActivePositions();      // existing function we added earlier
  const fromWallet = await readHoldingsFromWallet();
  const map = new Map();
  for (const p of [...fromLocal, ...fromWallet]) {
    const prev = map.get(p.mint) || 0;
    map.set(p.mint, prev + Number(p.qty || 0));
  }
  // Return [{mint, qty}] but exclude native SOL mint (we handle SOL cash separately)
  return Array.from(map.entries())
    .filter(([mint]) => mint !== 'So11111111111111111111111111111111111111112')
    .map(([mint, qty]) => ({ mint, qty }));
}

/** Format price with dynamic precision */
function formatPrice(price) {
  if (price >= 1) return price.toFixed(2);
  if (price >= 0.01) return price.toFixed(4);
  if (price >= 0.00001) return price.toFixed(6);
  // Use compact notation showing zeros count (e.g., 0.0^4 5 for 0.00005)
  if (price > 0) {
    const priceStr = price.toFixed(20); // Get enough decimals
    const match = priceStr.match(/^0\.(0+)([1-9]\d*)/);
    if (match) {
      const zeros = match[1].length;
      const digits = match[2].substring(0, 2); // Take first 2 significant digits
      return `0.0^${zeros}${digits}`;
    }
  }
  return '0';
}

/** Render positions table with token names, quantities, prices, and PnL */
let currentSortColumn = null;
let currentSortDirection = 'desc';
let cachedPositionsData = [];

async function renderPositionsTable(positions, prices) {
  const tbody = document.getElementById('pos-body');
  if (!tbody) return;
  
  tbody.innerHTML = '';
  
  if (!positions || positions.length === 0) {
    tbody.innerHTML = '<tr><td colspan="8" class="nx-td text-center text-zinc-400">No positions found</td></tr>';
    return;
  }
  
  // Fetch token metadata for display names
  let tokenMetadata = new Map();
  
  console.log('[Portfolio] Fetching metadata for', positions.length, 'tokens...');
  
  const metadataPromises = positions.map(async (pos) => {
    try {
      // Try DexScreener first (fast for tracked tokens)
      const dsResponse = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${pos.mint}`);
      if (dsResponse.ok) {
        const dsData = await dsResponse.json();
        if (dsData.pairs && dsData.pairs.length > 0) {
          const pair = dsData.pairs[0];
          return {
            mint: pos.mint,
            symbol: pair.baseToken?.symbol || pos.mint.slice(0, 6),
            name: pair.baseToken?.name || 'Unknown Token'
          };
        }
      }
      
      // Fallback: Use RPC to get mint account and try to parse metadata URI
      const rpc = window.NX_RPC || 'https://api.mainnet-beta.solana.com';
      const connection = new solanaWeb3.Connection(rpc);
      const mintPubkey = new solanaWeb3.PublicKey(pos.mint);
      
      // Try to get metadata account (Metaplex standard)
      const TOKEN_METADATA_PROGRAM_ID = new solanaWeb3.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
      
      // Derive metadata PDA
      const seeds = [
        new TextEncoder().encode('metadata'),
        TOKEN_METADATA_PROGRAM_ID.toBytes(),
        mintPubkey.toBytes()
      ];
      
      const [metadataPDA] = await solanaWeb3.PublicKey.findProgramAddress(seeds, TOKEN_METADATA_PROGRAM_ID);
      const accountInfo = await connection.getAccountInfo(metadataPDA);
      
      if (accountInfo && accountInfo.data) {
        // Simple parsing of Metaplex metadata
        const data = new Uint8Array(accountInfo.data);
        
        // Skip first 1 + 32 + 32 bytes (key + update_authority + mint)
        let offset = 1 + 32 + 32;
        
        // Read name length (4 bytes little endian)
        const nameLen = data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
        offset += 4;
        
        // Read name string
        const nameBytes = data.slice(offset, offset + nameLen);
        const name = new TextDecoder().decode(nameBytes).replace(/\0/g, '').trim();
        offset += nameLen;
        
        // Read symbol length
        const symbolLen = data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
        offset += 4;
        
        // Read symbol string
        const symbolBytes = data.slice(offset, offset + symbolLen);
        const symbol = new TextDecoder().decode(symbolBytes).replace(/\0/g, '').trim();
        
        if (symbol) {
          return {
            mint: pos.mint,
            symbol: symbol,
            name: name || symbol
          };
        }
      }
    } catch(e) {
      console.warn('[Portfolio] Failed to fetch metadata for', pos.mint, ':', e.message);
    }
    
    return {
      mint: pos.mint,
      symbol: pos.mint.slice(0, 6) + '...' + pos.mint.slice(-4),
      name: 'Unknown Token'
    };
  });
  
  const metadataResults = await Promise.all(metadataPromises);
  metadataResults.forEach(meta => {
    tokenMetadata.set(meta.mint, meta);
  });
  
  console.log('[Portfolio] Loaded metadata for', tokenMetadata.size, 'tokens');
  
  // Build rows data
  cachedPositionsData = positions.map(pos => {
    const meta = tokenMetadata.get(pos.mint);
    const symbol = meta?.symbol || pos.mint.slice(0, 6) + '...' + pos.mint.slice(-4);
    const name = meta?.name || 'Unknown Token';
    const priceData = prices?.[pos.mint];
    const price = priceData?.usdPrice || 0;
    const qty = pos.qty || 0;
    const value = price * qty;
    const avgCost = price;
    const unrealized = 0;
    const pct = 0;
    
    return { symbol, name, qty, avgCost, price, value, unrealized, pct, mint: pos.mint };
  });
  
  // Apply current sort if any
  if (currentSortColumn) {
    sortPositionsData(currentSortColumn);
  }
  
  // Render rows
  for (const row of cachedPositionsData) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="nx-td">
        <strong>${row.symbol}</strong>
        <div class="text-xs text-zinc-400">${row.name}</div>
      </td>
      <td class="nx-td tabnums">${row.qty.toLocaleString(undefined, {maximumFractionDigits: 2})}</td>
      <td class="nx-td tabnums">$${formatPrice(row.avgCost)}</td>
      <td class="nx-td tabnums">$${formatPrice(row.price)}</td>
      <td class="nx-td tabnums">$${row.value.toFixed(2)}</td>
      <td class="nx-td tabnums ${row.unrealized >= 0 ? 'pos-green' : 'pos-red'}">$${row.unrealized.toFixed(2)}</td>
      <td class="nx-td tabnums ${row.pct >= 0 ? 'pos-green' : 'pos-red'}">${row.pct.toFixed(2)}%</td>
      <td class="nx-td">
        <button class="nx-btn text-xs" onclick="NX.goToCoin({mint: '${row.mint}', symbol: '${row.symbol}', pair: '${row.symbol}/SOL'})">View</button>
      </td>
    `;
    tbody.appendChild(tr);
  }
}

/** Sort positions data by column */
function sortPositionsData(column) {
  if (currentSortColumn === column) {
    currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
  } else {
    currentSortColumn = column;
    currentSortDirection = 'desc';
  }
  
  cachedPositionsData.sort((a, b) => {
    let valA, valB;
    
    switch(column) {
      case 'token':
        valA = a.symbol.toLowerCase();
        valB = b.symbol.toLowerCase();
        break;
      case 'qty':
        valA = a.qty;
        valB = b.qty;
        break;
      case 'avgCost':
        valA = a.avgCost;
        valB = b.avgCost;
        break;
      case 'price':
        valA = a.price;
        valB = b.price;
        break;
      case 'value':
        valA = a.value;
        valB = b.value;
        break;
      case 'unrealized':
        valA = a.unrealized;
        valB = b.unrealized;
        break;
      case 'pct':
        valA = a.pct;
        valB = b.pct;
        break;
      default:
        return 0;
    }
    
    if (typeof valA === 'string') {
      return currentSortDirection === 'asc' 
        ? valA.localeCompare(valB)
        : valB.localeCompare(valA);
    } else {
      return currentSortDirection === 'asc'
        ? valA - valB
        : valB - valA;
    }
  });
  
  // Update sort indicators
  document.querySelectorAll('[data-sort]').forEach(th => {
    const arrow = th.dataset.sort === currentSortColumn 
      ? (currentSortDirection === 'asc' ? ' ▴' : ' ▾')
      : ' ▾';
    th.textContent = th.textContent.split(' ')[0] + arrow;
  });
  
  // Re-render table with sorted data
  const tbody = document.getElementById('pos-body');
  tbody.innerHTML = '';
  
  for (const row of cachedPositionsData) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="nx-td">
        <strong>${row.symbol}</strong>
        <div class="text-xs text-zinc-400">${row.name}</div>
      </td>
      <td class="nx-td tabnums">${row.qty.toLocaleString(undefined, {maximumFractionDigits: 2})}</td>
      <td class="nx-td tabnums">$${formatPrice(row.avgCost)}</td>
      <td class="nx-td tabnums">$${formatPrice(row.price)}</td>
      <td class="nx-td tabnums">$${row.value.toFixed(2)}</td>
      <td class="nx-td tabnums ${row.unrealized >= 0 ? 'pos-green' : 'pos-red'}">$${row.unrealized.toFixed(2)}</td>
      <td class="nx-td tabnums ${row.pct >= 0 ? 'pos-green' : 'pos-red'}">${row.pct.toFixed(2)}%</td>
      <td class="nx-td">
        <button class="nx-btn text-xs" onclick="NX.goToCoin({mint: '${row.mint}', symbol: '${row.symbol}', pair: '${row.symbol}/SOL'})">View</button>
      </td>
    `;
    tbody.appendChild(tr);
  }
}

// Add click listeners to sortable headers
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('[data-sort]').forEach(th => {
    th.addEventListener('click', () => {
      sortPositionsData(th.dataset.sort);
    });
  });
});

async function recompute(){
  // 1) Balance → from NXWallet (already connected) - use refreshBalance if needed
  try {
    if (window.NXWallet?.isConnected?.()) {
      await window.NXWallet.refreshBalance?.(false); // false = don't force if recent
    }
    SOL_BAL = +window.NXWallet?.getBalance?.() || 0;
  } catch(e) {
    console.warn('[Portfolio] Balance read failed:', e);
    SOL_BAL = 0;
  }

  // 2) Load open positions from any known key(s)
  const positions = await getAllPositions(); // [{mint, qty}]
  // 3) Fetch prices for SOL + all position mints
  const mints = Array.from(new Set([SOL_MINT, ...positions.map(p => p.mint)]));
  const prices = await getPrices(mints);
  LAST_SOL_USD = prices?.[SOL_MINT]?.usdPrice ?? null;

  // 4) Value open positions in USD
  let tradesUsd = 0;
  for (const p of positions) {
    const px = +((prices?.[p.mint]?.usdPrice) ?? 0);
    if (px && p.qty) tradesUsd += (px * p.qty);
  }

  // 5) Paint UI
  paintCash(LAST_SOL_USD);
  paintTotals({ tradesUsd, solUsd: LAST_SOL_USD });
  
  // 6) Render positions table
  await renderPositionsTable(positions, prices);

  // 7) Log diagnostics so you can see exactly what was read
  console.table({
    SOL_BAL,
    positions_found: positions.length,
    unique_mints_priced: mints.length,
    sol_usd: LAST_SOL_USD,
    trades_usd: tradesUsd,
    total_usd: tradesUsd + (LAST_SOL_USD ? SOL_BAL*LAST_SOL_USD : 0)
  });
}

// live updates when balance changes
window.addEventListener('nebula:sol:changed', (e)=>{
  SOL_BAL = +(e.detail?.balance || 0);
  paintCash(LAST_SOL_USD);
  // Don't call recompute here - it causes refresh loop
  // Just repaint totals with existing data
  const tradesUsd = 0; // Keep last calculated value instead of recalculating
  paintTotals({ tradesUsd, solUsd: LAST_SOL_USD });
});

// boot now and every 30s to refresh prices
let RECOMPUTE_INTERVAL = null;
(async function boot(){
  paintCash(LAST_SOL_USD);
  
  // Wait for NXWallet to be ready
  if (window.NXWallet?.isConnected?.()) {
    await recompute();
  }
  
  // Clear any existing intervals to prevent stacking
  if (RECOMPUTE_INTERVAL) clearInterval(RECOMPUTE_INTERVAL);
  RECOMPUTE_INTERVAL = setInterval(recompute, 30000);
})();

// Listen for wallet connection events
window.addEventListener('nxwallet:connected', async () => {
  console.log('[Portfolio] Wallet connected, refreshing data...');
  await recompute();
});

window.addEventListener('nxwallet:disconnected', () => {
  console.log('[Portfolio] Wallet disconnected');
  const tbody = document.getElementById('pos-body');
  if (tbody) tbody.innerHTML = '<tr><td colspan="8" class="nx-td text-center text-zinc-400">Connect wallet to view positions</td></tr>';
});
</script>


  </body>
</html>
