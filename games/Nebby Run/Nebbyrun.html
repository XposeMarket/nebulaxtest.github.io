<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NebulaX Runner – Demo (v2)</title>
  <style>
    :root{
      --bg:#050710; --border:#1a2244; --neon:#00f0ff; --text:#e7ecff;
    }
    html,body{height:100%}
    body{ margin:0; background: radial-gradient(1200px 800px at 50% -200px, #0f1733 0%, #050710 55%, #02040a 100%);
      color:var(--text); font: 500 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; overflow:hidden; }
    canvas{ display:block; width:100vw; height:100vh; }
    #hud{ position:fixed; inset:0; pointer-events:none; display:grid; grid-template-rows:auto 1fr auto; }
    .topbar{ display:flex; gap:.75rem; align-items:center; padding:.6rem .8rem;
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.15)); border-bottom:1px solid var(--border); backdrop-filter: blur(6px); }
    .badge{ padding:.25rem .5rem; border:1px solid var(--border); border-radius:999px; background:rgba(12,16,35,.7); }
    .glow{ color:var(--neon); text-shadow:0 0 8px rgba(0,240,255,.7); }
    .title{ font-weight:700; text-transform:uppercase; letter-spacing:.12em; font-size:12px; opacity:.9 }
    .spacer{ flex:1 }
    .btn{ pointer-events:auto; background: linear-gradient(180deg, #111831, #0b1126); color:var(--text);
      border:1px solid var(--border); border-radius:10px; padding:.55rem .8rem; font-weight:700; cursor:pointer; }
    .legend{ position:fixed; left:.75rem; bottom:.75rem; pointer-events:none; opacity:.85;
      background:rgba(4,6,14,.65); border:1px solid var(--border); border-radius:12px; padding:.6rem .75rem; }
    #centerMsg{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; font-weight:800; text-transform:uppercase; text-align:center; }
    #centerMsg .card{ background:rgba(0,0,0,.5); border:1px solid var(--border); padding:18px 22px; border-radius:14px; box-shadow:0 20px 80px rgba(0,0,0,.6);}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="hud">
    <div class="topbar">
      <span class="title">NebulaX Runner · Demo v2</span>
      <span class="badge"><span class="glow">Score</span> <span id="score">0</span></span>
      <span class="badge">Best <span id="best">0</span></span>
      <span class="badge">Speed <span id="speed">1.0x</span></span>
      <span class="badge">Scale <span id="scale">0.70</span></span>
      <div class="spacer"></div>
      <button class="btn" id="pauseBtn" title="P">Pause</button>
      <button class="btn" id="playBtn" title="Enter">Play</button>
    </div>
  </div>
  <div id="centerMsg"></div>
  <div class="legend">←/→ Rotate • Space Jump/Double • [ / ] Scale • P Pause • R Restart</div>

  <script>
  (()=>{
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');
    let w=0,h=0,dpr=1; const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const speedEl = document.getElementById('speed');
    const scaleEl = document.getElementById('scale');
    const centerMsg = document.getElementById('centerMsg');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');

    const STATE = { Idle:0, Playing:1, Paused:2, GameOver:3 };
    let state = STATE.Idle;
    let dtGlobal = 0;
    let rafId = 0;

    // === Nebby assets & animation ===
    const RUN_FRAMES = 6;
    const RUN_FPS = 12;
    let NEBBY_SCALE = 0.30;       // overall size multiplier (editable at runtime with [ and ])
    const USE_SPRITESHEET_IF_AVAILABLE = true;

    const nebby = {
      staticImg: new Image(),
      runImg: new Image(),
      hasStatic: false,
      hasRun: false,
      frameW: 0,
      frameH: 0,
      t: 0,                        // run clock
    };

    // Load images from ./assets
    nebby.staticImg.onload = ()=>{ nebby.hasStatic = true; };
    nebby.staticImg.onerror = ()=>{ console.warn('[Nebby] static image not found (assets/nebby_static.png)'); };
    nebby.staticImg.src = 'assets/nebby_static.png';

    nebby.runImg.onload = ()=>{
      nebby.hasRun = true;
      nebby.frameW = nebby.runImg.width / RUN_FRAMES;
      nebby.frameH = nebby.runImg.height;
    };
    nebby.runImg.onerror = ()=>{ console.warn('[Nebby] run spritesheet not found (assets/nebby_run_sheet.png) – falling back to single PNG.'); };
    nebby.runImg.src = 'assets/nebby_run_sheet.png';

    // Show live scale
    function showScale(){ scaleEl.textContent = NEBBY_SCALE.toFixed(2); }
    showScale();

    // Runtime scale controls: [ and ]
    addEventListener('keydown', (e)=>{
      if(e.code==='BracketLeft'){ NEBBY_SCALE = Math.max(0.10, NEBBY_SCALE - 0.05); showScale(); }
      if(e.code==='BracketRight'){ NEBBY_SCALE = Math.min(2.00, NEBBY_SCALE + 0.05); showScale(); }
    });

    // ===== Tunnel world (same as before)... minimal to keep this focused =====
    const TWO_PI = Math.PI*2;
    const ANG_SEGS = 16;
    const RADIUS_NORM = 0.42;
    let speed = 1.0;
    const plats = [];
    const stars = [];
    const rnd = (a,b)=>a+Math.random()*(b-a);

    function resize(){
      dpr = DPR; w = Math.floor(innerWidth*dpr); h=Math.floor(innerHeight*dpr);
      cvs.width = w; cvs.height = h; cvs.style.width=innerWidth+'px'; cvs.style.height=innerHeight+'px';
    }
    addEventListener('resize', resize); resize();

    // ... (Physics & game state copied from earlier build, trimmed for brevity)
    let seg = 0, targetSeg = 0, ang = 0;
    let y = 0, vy = 0, grounded = true;
    let usedDouble = false;
    let fallLocked = false;
    let last, score=0, elapsed=0, baseTick=0, bonusTick=0, speedTick=0, zScroll=0;
    const BEST_KEY='nx_runner_best_points';
    const formatInt = n=>Math.floor(n).toLocaleString();
    const best = +localStorage.getItem(BEST_KEY)||0; bestEl.textContent=formatInt(best);

    function reset(){
      targetSeg = seg = 0;
      ang = (Math.PI/2);
      y = 0; vy = 0; grounded = true; fallLocked = false; usedDouble = false;
      plats.length=0; score=0; elapsed=0; baseTick=0; bonusTick=0; speedTick=0; last=undefined; speed=1.0; nebby.t=0;
      speedEl.textContent=speed.toFixed(1)+'x';

      spawnFullRing(0.05, 0.6);
      ensureAhead();

      if(stars.length===0){
        for(let i=0;i<140;i++) stars.push({
          x:rnd(-1,1), y:rnd(-1,1), phase:rnd(0,Math.PI*2), w:rnd(0.2,0.5), amp:rnd(0.3,0.7), size:rnd(0.8,1.6),
          driftX:rnd(-0.02,0.02), driftY:rnd(-0.01,0.01)
        });
      }
    }

    function spawnFullRing(z,len){ plats.push({z,len,arcs:[{a1:0,a2:TWO_PI}]}); }
    function spawnBand(z){
      const GAP_MIN = TWO_PI*0.08, GAP_MAX = TWO_PI*0.22;
      const gapsN = Math.random()<0.55?1:(Math.random()<0.6?2:3);
      const centers=[]; for(let i=0;i<gapsN;i++){ centers.push(i*TWO_PI/gapsN + ((Math.random()-0.5)*0.5)*(TWO_PI/gapsN)); }
      centers.sort((a,b)=>a-b);
      const gaps = centers.map(c=>{
        const w = GAP_MIN + Math.random()*(GAP_MAX-GAP_MIN);
        return {a1:wrap(c-w/2), a2:wrap(c+w/2)};
      });
      const arcs=[];
      for(let i=0;i<gaps.length;i++){
        const cur=gaps[i], nxt=gaps[(i+1)%gaps.length];
        arcs.push({a1:cur.a2, a2:nxt.a1});
      }
      plats.push({z, len:0.30+Math.random()*0.60, arcs});
    }
    function farthestEndZ(){ let far=0; for(const p of plats) far=Math.max(far, p.z+p.len); return far; }
    function ensureAhead(){
      let far=farthestEndZ();
      while(far < 7.0){ const nextZ = far + (0.22+Math.random()*0.33); spawnBand(nextZ); far=farthestEndZ(); }
    }

    function FOV(){ return 1.8; }
    function project(z){ return FOV()/(FOV()+z); }
    function cx(){ return (w/dpr)/2; }
    function cy(){ return (h/dpr)/2; }
    function wrap(a){ a%=TWO_PI; if(a<0) a+=TWO_PI; return a; }
    function segCenter(i){ return wrap(Math.PI/2 + i*(TWO_PI/16)); }
    function angleLerp(a,b,t){ let d = wrap(b - a); if(d>Math.PI) d -= TWO_PI; return wrap(a + d*t); }
    function angleInArc(a,a1,a2){
      a=wrap(a); a1=wrap(a1); a2=wrap(a2);
      const span = (a2 - a1 + TWO_PI) % TWO_PI;
      if(span < 1e-4) return true;
      return (a1<=a2) ? (a>=a1 && a<=a2) : (a>=a1 || a<=a2);
    }
    function hasGround(){
      for(const p of plats){
        if(p.z < 0.08 && (p.z+p.len) > -0.04){
          for(const a of p.arcs){ if(angleInArc(ang, a.a1, a.a2)) return true; }
        }
      }
      return false;
    }

    // Track if this is first game start or restart
    let isFirstStart = true;
    let canRestart = true; // Track if player can restart (has turns)

    function actuallyStartGame(){
      cancelLoop(); 
      reset(); 
      state = STATE.Playing; 
      centerMsg.innerHTML=''; 
      last=performance.now(); 
      rafId=requestAnimationFrame(loop);
    }

    function startGame(){ 
      // Check if restart is allowed
      if(!canRestart && !isFirstStart){
        showMsg('<div style="text-align:center"><div style="font-size:1.8em;margin-bottom:8px">Out of Turns</div><div style="font-size:0.9em;opacity:0.8">Purchase more turns to play again</div></div>');
        return;
      }
      
      // If not first start, notify parent that game is restarting (consume a turn)
      if(!isFirstStart && window.parent){
        // Prevent multiple restart requests being posted while waiting for panel response
        if(window.__nebx_restart_requested){
          console.log('Restart already requested; awaiting panel response');
          return;
        }
        window.__nebx_restart_requested = true;
        window.parent.postMessage({type:'nebx:game:restart'}, '*');
        // Wait for parent response - don't start yet
        return;
      }
      
      // First start - no turn needed
      isFirstStart = false;
      actuallyStartGame();
    }
    
    // Listen for messages from parent
    window.addEventListener('message', (e) => {
      const d = e?.data || {};
      
      // Parent blocked restart - no turns left
      if(d.type === 'nebx:block:restart'){
        canRestart = false;
        showMsg('<div style="text-align:center"><div style="font-size:1.8em;margin-bottom:8px">Out of Turns</div><div style="font-size:0.9em;opacity:0.8">Purchase more turns to play again</div></div>');
      }
      
      // Parent allowed restart - continue with game start
      if(d.type === 'nebx:allow:restart'){
        // panel allowed restart; reset request flag and start
        window.__nebx_restart_requested = false;
        canRestart = true;
        actuallyStartGame();
      }
      
      // Reset turn availability when new turns purchased
      if(d.type === 'nebx:turns:purchased'){
        // reset restart request state when new turns are purchased
        window.__nebx_restart_requested = false;
        canRestart = true;
        isFirstStart = true;
      }
      // If panel explicitly blocks restart, clear the request flag so UI can react
      if(d.type === 'nebx:block:restart'){
        window.__nebx_restart_requested = false;
        canRestart = false;
        showMsg('<div style="text-align:center"><div style="font-size:1.8em;margin-bottom:8px">Out of Turns</div><div style="font-size:0.9em;opacity:0.8">Purchase more turns to play again</div></div>');
      }
    });
    
    function togglePause(){
      if(state===STATE.Playing){ state=STATE.Paused; cancelLoop(); showMsg('Paused'); }
      else if(state===STATE.Paused){ state=STATE.Playing; centerMsg.innerHTML=''; last=performance.now(); rafId=requestAnimationFrame(loop); }
    }
    function cancelLoop(){ if(rafId){ cancelAnimationFrame(rafId); rafId=0; } }
    function doJump(){
      const JUMP1_V=-11, JUMP2_V=-9.5, GRAVITY=22;
      if(grounded){ vy = JUMP1_V; grounded=false; fallLocked=false; usedDouble=false; }
      else if(!usedDouble){ vy = JUMP2_V; usedDouble=true; }
    }

    addEventListener('keydown', e=>{
      if(['ArrowLeft','ArrowRight','Space','KeyR','KeyP','Enter'].includes(e.code)) e.preventDefault();
      if(e.code==='ArrowLeft'){ targetSeg=(targetSeg+1)%16; }
      if(e.code==='ArrowRight'){ targetSeg=(targetSeg-1+16)%16; }
      if(e.code==='Space'){ doJump(); }
      if(e.code==='KeyR'){ startGame(); }
      if(e.code==='KeyP'){ togglePause(); }
      if(e.code==='Enter'){ if(state!==STATE.Playing) startGame(); }
    });
    playBtn.onclick = ()=> startGame();
    pauseBtn.onclick = ()=> togglePause();

    function loop(ts){
      if(state!==STATE.Playing) return; 
      const dt = Math.min(0.032, (ts-(last??ts))/1000); last=ts; dtGlobal = dt;

      if(elapsed >= 30){ speedTick += dt; while(speedTick>=10){ speed += 0.05; speedTick -= 10; } }
      speedEl.textContent = speed.toFixed(1)+'x';

      ang = angleLerp(ang, segCenter(targetSeg), Math.min(1, dt*10));

      const GRAVITY = 22, MAX_FALL_V = 9.5, DEATH_Y = 1.0;
      vy += GRAVITY*dt; if(vy > MAX_FALL_V) vy = MAX_FALL_V;
      y += vy*dt;
      if(y > 0.25) fallLocked = true;

      const onGround = hasGround();
      if(onGround && !fallLocked && vy > 0 && y >= 0){
        y = 0; vy = 0; grounded = true; usedDouble = false;
      } else {
        grounded = false;
        if (y > DEATH_Y) { return gameOver(); }
      }

      ensureAhead();
      const zspeed = 1.5*speed;
      zScroll += zspeed*dt;
      for(let i=plats.length-1;i>=0;i--){ const p=plats[i]; p.z -= zspeed*dt; if(p.z+p.len<-0.2) plats.splice(i,1); }

      elapsed += dt;
      
      // Award points per frame (~60fps = smooth counting effect)
      // This gives roughly 1000 points per second while creating that rapid ticking effect
      score += 16; // ~1000 points/sec at 60fps
      
      // Send bulk points to parent every 1 second to avoid spam
      baseTick += dt;
      while(baseTick >= 1.0){ 
        if(window.parent && window.parent !== window){
          window.parent.postMessage({type:'nebx:points', delta:1000}, '*');
        }
        baseTick -= 1.0; 
      }
      scoreEl.textContent = formatInt(score);

      nebby.t += dt * (grounded ? RUN_FPS : RUN_FPS*0.6);

      draw();
      rafId = requestAnimationFrame(loop);
    }

    function gameOver(){
      state = STATE.GameOver; cancelLoop();
      const newBest=Math.max(+localStorage.getItem(BEST_KEY)||0, Math.floor(score));
      if(newBest!==(+localStorage.getItem(BEST_KEY)||0)) localStorage.setItem(BEST_KEY,newBest);
      bestEl.textContent = formatInt(newBest);
      showMsg('GAME OVER<br><small>Press Enter or R to restart</small>');
      // Notify parent panel about game over so it can consume a turn
      try{
        const payload = { type: 'nebby-runner:gameover', score: Math.floor(score), level: 1, reason: 'death' };
        // send once per session to avoid duplicate messages
        if(!window.__nebx_gameover_sent){
          window.__nebx_gameover_sent = true;
          if(window.parent && window.parent !== window) window.parent.postMessage(payload, '*');
        }
        try{ window.dispatchEvent(new CustomEvent('nebbyRunnerGameOver', { detail: payload })); }catch(e){}
      }catch(e){}
    }
    function showMsg(html){ centerMsg.innerHTML = '<div class="card"><div class="glow" style="font-size:28px">'+html+'</div></div>'; }

    // ===== Drawing =====
    function draw(){
      ctx.setTransform(dpr,0,0,dpr,0,0);
      // background
      const g = ctx.createLinearGradient(0,0,0,h/dpr); g.addColorStop(0,'#050815'); g.addColorStop(1,'#02040a');
      ctx.fillStyle=g; ctx.fillRect(0,0,w/dpr,h/dpr);

      // stars
      ctx.save(); ctx.translate(cx(), cy());
      for(const s of stars){
        s.x += (s.driftX||0) * dtGlobal; s.y += (s.driftY||0) * dtGlobal;
        if(s.x < -1) s.x = 1; if(s.x > 1) s.x = -1;
        if(s.y < -1) s.y = 1; if(s.y > 1) s.y = -1;
        s.phase = (s.phase||0) + (s.w||0.3) * dtGlobal;
        const a = 0.25 + 0.75 * (0.5 + 0.5 * Math.sin(s.phase)) * (s.amp||0.5);
        const sx = s.x * (w/dpr) * 0.48; const sy = s.y * (h/dpr) * 0.48;
        ctx.globalAlpha = a; ctx.fillStyle = '#e7f9ff'; ctx.fillRect(sx, sy, (s.size||1.2), (s.size||1.2));
      }
      ctx.globalAlpha = 1; ctx.restore();

      // tunnel grid
      const R = Math.min(w/dpr,h/dpr)*RADIUS_NORM;
      const rot = ang - Math.PI/2;
      for(let step=0; step<18; step++){
        const base = (zScroll % 0.14);
        const zNear=0.12 + step*0.14 - base, zFar=zNear+0.14; const s1=project(zNear), s2=project(zFar);
        const r1=R*s1, r2=R*s2; const aStep=TWO_PI/ANG_SEGS;
        for(let j=0;j<ANG_SEGS;j++){
          const a1=j*aStep - rot, a2=(j+1)*aStep - rot;
          const p1x=cx()+Math.cos(a1)*r1, p1y=cy()+Math.sin(a1)*r1;
          const p2x=cx()+Math.cos(a2)*r1, p2y=cy()+Math.sin(a2)*r1;
          const p3x=cx()+Math.cos(a2)*r2, p3y=cy()+Math.sin(a2)*r2;
          const p4x=cx()+Math.cos(a1)*r2, p4y=cy()+Math.sin(a1)*r2;
          ctx.fillStyle = step%2 ? '#0b0f1f' : '#0a0e1b'; ctx.globalAlpha=0.35;
          ctx.beginPath(); ctx.moveTo(p1x,p1y); ctx.lineTo(p2x,p2y); ctx.lineTo(p3x,p3y); ctx.lineTo(p4x,p4y); ctx.closePath(); ctx.fill();
          ctx.globalAlpha=0.5; ctx.strokeStyle='#00e5ff'; ctx.beginPath(); ctx.moveTo(p1x,p1y); ctx.lineTo(p4x,p4y); ctx.moveTo(p2x,p2y); ctx.lineTo(p3x,p3y); ctx.stroke(); ctx.globalAlpha=1;
        }
      }

      // platforms (safe arcs)
      for(const p of plats){
        const s1=project(p.z), s2=project(p.z+p.len); const r1=R*s1, r2=R*s2; 
        for(const a of p.arcs){ drawArcQuad(a.a1 - rot, a.a2 - rot, r1, r2); }
      }

      // player position at near radius
      const sP=project(0.06), rP=R*sP; 
      const basePx=cx(); 
      const basePy=cy()+rP + y*22;

      drawNebby(basePx, basePy);
    }

    function drawArcQuad(a1,a2,r1,r2){
      let start=a1, end=a2;
      while(end < start) end += TWO_PI;
      const span = Math.max(1e-4, end - start);
      const step = Math.max(TWO_PI/40, span/8);
      for(let a=start; a<end; a+=step){
        const b = Math.min(end, a+step);
        quad((a)%TWO_PI, (b)%TWO_PI, r1, r2);
      }
    }
    function quad(a1,a2,r1,r2){
      const p1x=cx()+Math.cos(a1)*r1, p1y=cy()+Math.sin(a1)*r1;
      const p2x=cx()+Math.cos(a2)*r1, p2y=cy()+Math.sin(a2)*r1;
      const p3x=cx()+Math.cos(a2)*r2, p3y=cy()+Math.sin(a2)*r2;
      const p4x=cx()+Math.cos(a1)*r2, p4y=cy()+Math.sin(a1)*r2;
      ctx.fillStyle='#00f0ff'; ctx.beginPath(); ctx.moveTo(p1x,p1y); ctx.lineTo(p2x,p2y); ctx.lineTo(p3x,p3y); ctx.lineTo(p4x,p4y); ctx.closePath(); ctx.fill();
      ctx.strokeStyle='#bffaff'; ctx.globalAlpha=0.65; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(p1x,p1y); ctx.lineTo(p4x,p4y); ctx.moveTo(p2x,p2y); ctx.lineTo(p3x,p3y); ctx.stroke(); ctx.globalAlpha=1;
    }

    // ===== Nebby rendering (uses NEBBY_SCALE everywhere) =====
    function drawNebby(px, py){
      // Shadow
      ctx.globalAlpha=0.28; ctx.fillStyle='#000';
      ctx.beginPath(); ctx.ellipse(px, py+6, 90*NEBBY_SCALE, 20*NEBBY_SCALE, 0, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1;

      // Bob + yaw
      const bob = Math.sin(nebby.t*Math.PI*2/ RUN_FPS) * 6 * (grounded?1:0.5);
      const tilt = Math.sin(nebby.t*0.5) * 0.05;

      ctx.save();
      ctx.translate(px, py + bob);
      ctx.rotate(tilt);

      if (USE_SPRITESHEET_IF_AVAILABLE && nebby.hasRun){
        const idx = Math.floor(nebby.t) % RUN_FRAMES;
        const sw = nebby.frameW, sh = nebby.frameH, sx = idx*sw, sy = 0;
        const targetW = sw * NEBBY_SCALE * 0.75;
        const targetH = sh * NEBBY_SCALE * 0.75;
        ctx.drawImage(nebby.runImg, sx, sy, sw, sh, -targetW/2, -targetH, targetW, targetH);
      } else if (nebby.hasStatic){
        const iw = nebby.staticImg.naturalWidth||nebby.staticImg.width, ih = nebby.staticImg.naturalHeight||nebby.staticImg.height;
        const targetW = iw * NEBBY_SCALE * 0.75;
        const targetH = ih * NEBBY_SCALE * 0.75;
        const squash = grounded ? (1 - 0.04 * (0.5 + 0.5*Math.sin(nebby.t*2))) : 1;
        ctx.scale(1, squash);
        ctx.drawImage(nebby.staticImg, -targetW/2, -targetH, targetW, targetH);
      } else {
        const r=22*NEBBY_SCALE;
        ctx.fillStyle='#9fb6ff';
        ctx.beginPath(); ctx.ellipse(0, -r*0.2, r, r*0.8, 0, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    function cx(){ return (w/dpr)/2; }
    function cy(){ return (h/dpr)/2; }

    // Self-test invisible
    (function(){ try{ ctx.save(); ctx.globalAlpha=0; drawArcQuad(5.8,0.2,60,80); drawArcQuad(-1,1,80,100); drawArcQuad(0,Math.PI*2,40,60); ctx.restore(); } catch(e){ console.error(e); }})();
    showMsg('Press Enter to Play');

    // Expose some helpers for console tweaking if needed
    window._nebby = { get scale(){return NEBBY_SCALE}, set scale(v){ NEBBY_SCALE = Math.max(0.1, Math.min(2, +v||NEBBY_SCALE)); showScale(); } };

    function showMsg(html){ centerMsg.innerHTML = '<div class="card"><div class="glow" style="font-size:28px">'+html+'</div></div>'; }
  })();
  </script>
</body>
</html>
