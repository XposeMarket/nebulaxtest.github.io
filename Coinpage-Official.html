<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>NebulaX • Coin</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Force cache refresh -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
<script src="nx-theme.js"></script>
<link rel="stylesheet" href="assets/css/nx-mobile-banner.css">
<script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>
<script>
  window.NX_RPC = "https://rpc.helius.xyz/?api-key=3858d764-530d-4b75-b3df-619dc2613ff9";
</script>
<script src="assets/nx-wallet.js"></script>
<script src="assets/js/nx-search.js"></script>
<!-- Jupiter Swap Integration -->
<script src="https://unpkg.com/@solana/spl-token@0.3.8/lib/index.iife.min.js"></script>
<!-- QR Code Generator Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", async () => {
  const btn = document.getElementById("wallet-btn");
  function paint(sol){
    if (!btn) return;
    if (sol == null) {
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Connect Wallet`;
    } else {
      const s = sol.toFixed(3);
      btn.innerHTML = `<i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Bal: ${s} SOL`;
    }
    try { window.lucide?.createIcons?.(); } catch {}
  }
  if (window.NXWallet?.isConnected?.()) {
    try { await window.NXWallet.refreshBalance?.(true); } catch {}
    paint(window.NXWallet?.getBalance?.());
  } else {
    const prov = (window.phantom?.solana) || window.solana;
    try { await prov?.connect?.({ onlyIfTrusted: true }); } catch {}
    if (window.NXWallet?.isConnected?.()) {
      try { await window.NXWallet.refreshBalance?.(true); } catch {}
      paint(window.NXWallet?.getBalance?.());
    } else {
      paint(null);
    }
  }
  window.addEventListener("nebula:sol:changed", (e)=> paint(e.detail?.balance));
  window.addEventListener("nxwallet:connected", async ()=>{
    try { await window.NXWallet.refreshBalance?.(true); } catch {}
    paint(window.NXWallet?.getBalance?.());
  });
  window.addEventListener("nxwallet:disconnected", ()=> paint(null));
});
</script>
<style>
  :root {
    --nx-cyan:#00e6ff; --nx-dark:#0a0d1b; --nx-dark-2:#12152a;
    --nx-border:#1e2747; --nx-text:#e0e7ff;
  }
  html[data-theme="amber"]{ --nx-cyan:#ffb020; --nx-dark:#0b0b14; --nx-dark-2:#15162a; --nx-border:#2a2647; --nx-text:#ffeccc; }
  html[data-theme="violet"]{ --nx-cyan:#b69cff; --nx-dark:#0a0a16; --nx-dark-2:#131329; --nx-border:#27224a; --nx-text:#eae4ff; }
  html[data-theme="neon"]{ --nx-cyan:#55ffda; --nx-dark:#070b12; --nx-dark-2:#0d1220; --nx-border:#1a243a; --nx-text:#dbfff7; }

  .nx-tab { padding:.4rem .6rem; border-radius:.7rem; border:1px solid transparent; font-size:.85rem; }
  .nx-tab.active { border-color:var(--nx-border); background:rgba(255,255,255,.03); color:var(--nx-cyan); }
  .nx-btn { font-size:.8rem; padding:.35rem .6rem; border-radius:.6rem; border:1px solid var(--nx-border); }
  .nx-btn-outline { font-size:.8rem; padding:.35rem .6rem; border-radius:.6rem; border:1px dashed var(--nx-border); background:transparent; }
  input::placeholder { color: #7a86a8; }
</style>
    <style>
      :root{
        --nx-cyan:#00e6ff;
        --nx-dark:#0a0d1b;
        --nx-dark-2:#12152a;
        --nx-border:#1e2747;
        --nx-text:#e0e7ff;
        --page-max: 1400px;
        /* Adrenaline sidebar */
        --ad-w: 360px;
        --ad-gap: 18px;
      }
      html,body{height:100%; background:var(--nx-dark); font-family:'Orbitron','ui-monospace','SFMono-Regular',monospace; color:var(--nx-text);}
      .page-wrap{max-width:var(--page-max); margin:18px auto; padding:0 12px;}

      /* Panels */
      .nx-panel{
        background:rgba(16,20,40,.92);
        border:1px solid var(--nx-border);
        box-shadow: inset 0 0 10px rgba(0,230,255,.18), 0 0 12px rgba(0,230,255,.08);
        backdrop-filter: blur(8px);
        border-radius: 16px;
      }
      .nx-title{color:#ffeb3b;text-shadow:0 0 3px #ffeb3b;}
      .tabnums{font-variant-numeric: tabular-nums;}

      /* Buttons */
      .nx-btn{
        border-radius:14px; padding:.42rem .72rem; font-weight:700;
        transition:transform .05s ease, opacity .18s ease, box-shadow .18s ease;
        border:1px solid var(--nx-border); background:var(--nx-dark-2); color:var(--nx-text);
      }
      .nx-btn:hover{opacity:.95}
      .nx-btn:active{transform:translateY(1px)}
      .nx-btn-cyan{ background:var(--nx-cyan); color:#0b101b; border-color:#0d3540; box-shadow:0 0 10px rgba(0,230,255,.3); }
      .nx-btn-red{ background:#ef4444; color:#1b0707; }
      .nx-btn-green{ background:#10b981; color:#00130f; }

      /* Tabs (only active cyan) */
      .tab{
        border-radius:10px; padding:.45rem .8rem; font-weight:700;
        border:1px solid var(--nx-border); background:var(--nx-dark-2); color:#a5b4fc;
      }
      .tab.active{ background:var(--nx-cyan); color:#041018; box-shadow:0 0 10px rgba(0,230,255,.35); }

      /* Presets */
      .preset-btn{ padding:.38rem .6rem; font-size:.9rem; border-radius:12px; }
      .preset-btn.active{ background:var(--nx-cyan); color:#041018; border-color:#0d3540; box-shadow:0 0 10px rgba(0,230,255,.35); }

      /* Inputs */
      .nx-input{
        width:100%; border-radius:12px; border:1px solid var(--nx-border);
        background:var(--nx-dark-2); color:var(--nx-text); padding:.55rem .7rem; outline:none;
      }
      .nx-input:focus{border-color:var(--nx-cyan); box-shadow:0 0 0 2px rgba(0,230,255,.14)}

      /* Scrollbar */
      ::-webkit-scrollbar{width:10px;height:10px}
      ::-webkit-scrollbar-track{background:var(--nx-dark-2);border:1px solid #1b2450;border-radius:6px;box-shadow:inset 0 0 8px rgba(0,230,255,.12)}
      ::-webkit-scrollbar-thumb{border-radius:6px;background:var(--nx-cyan);box-shadow:0 0 8px rgba(0,230,255,.35);border:2px solid var(--nx-dark-2)}
      ::-webkit-scrollbar-thumb:hover{background:#6ff3ff}
      *{scrollbar-width:thin; scrollbar-color: var(--nx-cyan) var(--nx-dark-2)}

      /* Popovers */
      .popover{position:absolute; z-index:1000; border:1px solid var(--nx-border); background:rgba(13,16,34,.98); box-shadow:0 10px 30px rgba(0,0,0,.4); border-radius:12px;}

      /* Modal Overlays */
      .modal-fx{ position:fixed; inset:0; display:grid; place-items:center; z-index:2100; background:rgba(0,0,0,.55); padding:12px; }
      .modal-fx.hidden{ display:none !important; }

      /* Social Link Preview */
      .social-preview {
        position: absolute;
        top: calc(100% + 8px);
        right: 0;
        width: 400px;
        max-width: 90vw;
        height: 300px;
        background: rgba(13,16,34,.98);
        border: 1px solid var(--nx-border);
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0,0,0,.4), 0 0 20px rgba(0,230,255,.15);
        overflow: hidden;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-10px);
        transition: all 0.3s cubic-bezier(0.22, 0.61, 0.36, 1);
        pointer-events: none;
        z-index: 1500;
      }
      .social-preview.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
      }
      .social-preview iframe {
        width: 100%;
        height: 100%;
        border: none;
        border-radius: 12px;
      }
      .social-preview::before {
        content: '';
        position: absolute;
        top: -6px;
        right: 12px;
        width: 12px;
        height: 12px;
        background: rgba(13,16,34,.98);
        border-left: 1px solid var(--nx-border);
        border-top: 1px solid var(--nx-border);
        transform: rotate(45deg);
      }

      /* Toast Notifications */
      .nx-toast {
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 9999;
        min-width: 320px;
        max-width: 500px;
        padding: 16px 20px;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0,0,0,.4), 0 0 0 1px rgba(255,255,255,.1);
        backdrop-filter: blur(12px);
        animation: slideIn 0.3s cubic-bezier(0.22, 0.61, 0.36, 1);
        display: flex;
        align-items: start;
        gap: 12px;
      }
      
      .nx-toast.success {
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1));
        border: 1px solid rgba(16, 185, 129, 0.3);
      }
      
      .nx-toast.error {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.1));
        border: 1px solid rgba(239, 68, 68, 0.3);
      }
      
      .nx-toast-icon {
        flex-shrink: 0;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
      }
      
      .nx-toast.success .nx-toast-icon {
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
      }
      
      .nx-toast.error .nx-toast-icon {
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
      }
      
      .nx-toast-content {
        flex: 1;
        min-width: 0;
      }
      
      .nx-toast-title {
        font-weight: 700;
        font-size: 14px;
        margin-bottom: 4px;
      }
      
      .nx-toast.success .nx-toast-title {
        color: #10b981;
      }
      
      .nx-toast.error .nx-toast-title {
        color: #ef4444;
      }
      
      .nx-toast-message {
        font-size: 13px;
        color: #cbd5e1;
        line-height: 1.5;
        word-break: break-word;
      }
      
      .nx-toast-link {
        color: var(--nx-cyan);
        text-decoration: none;
        font-weight: 600;
        transition: opacity 0.2s;
      }
      
      .nx-toast-link:hover {
        opacity: 0.8;
        text-decoration: underline;
      }
      
      .nx-toast-close {
        flex-shrink: 0;
        width: 20px;
        height: 20px;
        border: none;
        background: rgba(255,255,255,0.1);
        color: #94a3b8;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        line-height: 1;
        transition: background 0.2s;
      }
      
      .nx-toast-close:hover {
        background: rgba(255,255,255,0.15);
      }
      
      @keyframes slideIn {
        from {
          transform: translateX(400px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      
      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(400px);
          opacity: 0;
        }
      }
      
      .nx-toast.hiding {
        animation: slideOut 0.3s cubic-bezier(0.22, 0.61, 0.36, 1) forwards;
      }

      /* SEARCH styling */
      #search-wrap:focus-within .nx-input{ border-color:var(--nx-cyan); box-shadow:0 0 0 2px rgba(0,230,255,.14); }
      .search-row{ display:flex; align-items:center; gap:.75rem; padding:.45rem .6rem; border-radius:10px; }
      .search-row:hover{ background: var(--nx-dark-2); }
      .search-icon{ height:2rem; width:2rem; display:flex; align-items:center; justify-content:center; border-radius:8px; background:var(--nx-dark-2); }
      .search-grid{ display:grid; grid-template-columns: 1fr auto auto auto; gap:.75rem; align-items:center; min-width:0; }
      .search-name{ min-width:0; }
      .search-name .ticker{ font-size:11px; color:#8b97c9; }
      .search-metric{ font-size:11px; color:#9fb3ff; white-space:nowrap; }
      .search-active{ outline:2px solid var(--nx-cyan); outline-offset:2px; }

      /* === Adrenaline overlay — left of LEFT panel, full panel height === */
      #leftColPanel{ position:relative; overflow:visible; }
      #leftColPanel .ad-slot{ position:absolute; inset:0; overflow:visible; pointer-events:none; z-index:6; }

      /* Vertical tab */
      #leftColPanel .adrenaline-tab{
        position:absolute; top:50%; left:-42px; transform:translateY(-50%);
        width:28px; height:140px; border-radius:16px; backdrop-filter:blur(6px);
        background:rgba(10,16,28,.85); border:1.5px solid #00E5FF;
        box-shadow:0 0 10px rgba(0,229,255,.45), 0 0 24px rgba(0,229,255,.28) inset;
        cursor:pointer; pointer-events:auto;
      }
#leftColPanel .adrenaline-tab span{
  writing-mode: vertical-lr;
  text-orientation: mixed;
  transform: rotate(180deg);
  transform-origin: center;
}

      #leftColPanel .adrenaline-tab::before{
        content:""; position:absolute; inset:-3px; border-radius:inherit; pointer-events:none;
        box-shadow:0 0 12px rgba(0,229,255,.55), 0 0 28px rgba(0,229,255,.35);
        animation: ad-flame 2.1s ease-in-out infinite alternate;
      }
      @keyframes ad-flame{
        0%{ box-shadow:0 0 10px rgba(0,229,255,.45), 0 0 20px rgba(0,229,255,.25); }
        100%{ box-shadow:0 0 18px rgba(0,229,255,.75), 0 0 36px rgba(0,229,255,.45); }
      }

      #leftColPanel .adrenaline-panel{
        position:absolute;
        top:0; bottom:0;                         /* full height of left panel */
        left: calc(-1 * (var(--ad-w) + var(--ad-gap)));
        width: var(--ad-w);
        border-radius:18px; overflow:hidden;
        background:rgba(8,12,22,.96);
        border:1px solid rgba(0,229,255,.35);
        box-shadow:0 0 40px rgba(0,229,255,.22);
        transform: translateX(-110%);            /* hidden by default */
        transition: transform .28s cubic-bezier(.22,.61,.36,1);
        pointer-events:none;
      }
      #leftColPanel .adrenaline-panel.open{
        transform: translateX(0);
        pointer-events:auto;
      }
      #leftColPanel .ad-header{
        display:flex; align-items:center; gap:12px;
        padding:12px 14px; border-bottom:1px solid rgba(0,229,255,.18);
      }
      #leftColPanel .ad-title{ font-weight:800; color:#BDF0FF; letter-spacing:.4px; }
      #leftColPanel .ad-views{
        margin-left:auto; display:inline-flex; gap:6px;
        background: rgba(255,255,255,.02);
        padding:4px; border-radius:12px; border:1px solid rgba(255,255,255,.06);
      }
      #leftColPanel .ad-view{
        font:inherit; padding:6px 10px; border-radius:8px;
        background:transparent; color:#9ab4ff; border:1px solid transparent;
      }
      #leftColPanel .ad-view.is-active{
        color:#061926; background:#19E5FF; border-color:rgba(0,229,255,.6);
        box-shadow:0 0 14px rgba(0,229,255,.35);
      }
      #leftColPanel .ad-close{
        margin-left:6px; width:28px; height:28px; line-height:26px;
        border-radius:8px; border:1px solid rgba(255,255,255,.08);
        background:rgba(255,255,255,.03); color:#a8b0c8;
      }
      #leftColPanel .ad-body{ height: calc(100% - 54px); }
      #leftColPanel #adrenalineFrame{ width:100%; height:100%; border:0; background:transparent; }

      /* Create room while open so nothing overflows */
      @media (min-width: 1024px){
        #mainGrid.ad-open{
          padding-left: calc(var(--ad-w) + var(--ad-gap));
          transition: padding-left .28s cubic-bezier(.22,.61,.36,1);
        }
      }
      /* Optional slightly smaller variant for narrower desktops */
      @media (max-width:1280px){
        :root{ --ad-w: 320px; --ad-gap: 16px; }
      }
    </style>
  </head>
  <body>
    <!-- Header -->
    <header class="sticky top-0 z-[1000] isolate border-b border-[var(--nx-border)] bg-[rgba(10,13,27,0.9)] backdrop-blur-sm">
      <div class="page-wrap h-7 px-1 flex items-center justify-between">
        <div class="flex items-center gap-3">
          <a href="NebulaX.html" class="flex items-center gap-2">
            <img src="NebulaX-logo.png" class="h-6 w-6 rounded-md" alt="NebulaX"/>
            <span class="font-bold tracking-wide" style="text-shadow:0 0 2px var(--nx-cyan);">NEBULAX</span>
          </a>
          <nav class="hidden sm:flex items-center gap-2 ml-2">
            <a class="nx-btn px-2 py-1 text-xs" href="NebulaX.html">Home</a>
            <a class="nx-btn px-2 py-1 text-xs" href="NewPairs-official.html">New Pairs</a>
            <a class="nx-btn px-2 py-1 text-xs" href="Trending.html">Trending</a>
            <a class="nx-btn px-2 py-1 text-xs" href="portfolio_official_v_2_fixed.html">Portfolio</a>
            <a class="nx-btn px-2 py-1 text-xs" href="Adrenaline-official.html">Adrenaline</a>
            <a class="nx-btn px-2 py-1 text-xs" href="nebula_x_store_official.html">Store</a>
          </nav>
        </div>

        <!-- SEARCH -->
        <div id="search-wrap" class="relative w-[26rem] max-w-[60vw]">
          <input id="search-input" class="nx-input" placeholder="Search markets... /" autocomplete="off"/>
          <div id="search-dd" class="popover hidden mt-1 w-full max-h-[22rem] overflow-auto p-2"></div>
        </div>

        <div class="flex items-center gap-2">
          <button id="wallet-btn" class="nx-btn"><i data-lucide="wallet" class="w-3 h-3 mr-2"></i> Connect Wallet</button>
          <button id="nx-profile" class="relative w-8 h-8 rounded-xl overflow-hidden border"
                  style="border-color:var(--nx-border)">
            <img id="nx-pfp" src="/pfp/default.png" alt="" class="absolute inset-0 w-full h-full object-cover" />
          </button>
        </div>
      </div>
    </header>

    <div class="page-wrap">
      <!-- Stats row -->
      <section class="mt-3">
        <div class="nx-panel p-3">
          <div class="grid grid-cols-2 md:grid-cols-6 gap-2 text-sm">
            <div id="stat-mcap" class="nx-btn tabnums">Market Cap: <span class="ml-1 text-emerald-400">—</span></div>
            <div id="stat-price" class="nx-btn tabnums">Price: <span class="ml-1 text-emerald-400">—</span></div>
            <div id="stat-liq" class="nx-btn tabnums">Liquidity: <span class="ml-1 text-emerald-400">—</span></div>
            <div id="stat-fdv" class="nx-btn tabnums">Supply: <span class="ml-1 text-emerald-400">—</span></div>
            <div id="stat-vol" class="nx-btn tabnums">24h Vol (mock): <span class="ml-1 text-emerald-400">—</span></div>
            <div class="flex justify-end">
              <button id="alerts-open" class="nx-btn nx-btn-cyan"><i data-lucide="bell-plus" class="w-4 h-4 mr-2"></i>Alerts</button>
            </div>
          </div>
        </div>
      </section>

      <!-- Main two-column -->
      <main id="mainGrid" class="mt-3 grid grid-cols-1 lg:grid-cols-[1fr_360px] gap-3">
        <!-- LEFT -->
        <section id="leftColPanel" class="nx-panel p-3">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-3">
              <div id="coin-logo" class="h-8 w-8 rounded-full bg-gradient-to-br from-cyan-500 to-purple-600 border border-[var(--nx-border)] overflow-hidden flex items-center justify-center text-xs"></div>
              <div>
                <div class="text-lg nx-title" id="coin-title">Loading...</div>
                <div class="text-xs text-zinc-500 mt-1 font-mono" id="title-ca">—</div>
              </div>
            </div>
            <div class="flex items-center gap-2" id="social-buttons" style="position: relative;">
              <!-- Social links will be populated here dynamically -->
              <div style="position: relative;">
                <button id="twitter-link" class="nx-btn h-8 w-8 grid place-items-center hidden" title="Twitter/X"><i data-lucide="twitter" class="w-4 h-4"></i></button>
                <div id="twitter-preview" class="social-preview">
                  <iframe id="twitter-iframe" sandbox="allow-scripts allow-same-origin" loading="lazy"></iframe>
                </div>
              </div>
              <div style="position: relative;">
                <button id="website-link" class="nx-btn h-8 w-8 grid place-items-center hidden" title="Website"><i data-lucide="globe" class="w-4 h-4"></i></button>
                <div id="website-preview" class="social-preview">
                  <iframe id="website-iframe" sandbox="allow-scripts allow-same-origin" loading="lazy"></iframe>
                </div>
              </div>
              <button class="nx-btn h-8 w-8 grid place-items-center" title="Star"><i data-lucide="star" class="w-4 h-4"></i></button>
              <button id="btn-share-pnl" class="nx-btn h-8 w-8 grid place-items-center" title="Share"><i data-lucide="share-2" class="w-4 h-4"></i></button>
            </div>
          </div>

          <!-- CHART CARD -->
          <div class="mt-3 relative nx-panel p-2 h-[500px]" id="coinChartPanel">
            <div id="chart-container" class="w-full h-full bg-[#090d16] rounded-[12px] border border-[var(--nx-border)]" style="position:relative; overflow:hidden; border-radius: 12px; display:flex; flex-direction:column;">
              <div id="chart-loading" class="w-full h-full grid place-items-center">
                <div class="text-center">
                  <div class="text-zinc-400 text-sm mb-2">Loading chart...</div>
                </div>
              </div>
              <iframe id="chart-iframe" class="flex-1" style="display:none; border:none; width:100%; margin-bottom:-30px;" frameborder="0"></iframe>
            </div>
          </div>

          <!-- Tabs -->
          <div class="mt-3 flex items-center gap-2 overflow-x-auto">
            <button class="tab active" data-tab="orderbook">Order Book</button>
            <button class="tab" data-tab="trades">Live Trades</button>
            <button class="tab" data-tab="holders">Holders</button>
            <button class="tab" data-tab="toptraders">Top Traders</button>
          </div>

          <div id="tab-content" class="mt-2 nx-panel p-3 text-sm">
            Tab Content Placeholder (e.g., Order Book Data)
          </div>

          <!-- === Adrenaline overlay slot (attached to the LEFT PANEL) === -->
          <div class="ad-slot" aria-hidden="true">
            <button class="adrenaline-tab" id="adrenalineTab" aria-controls="adrenalinePanel" aria-expanded="false">
              <span>Adrenaline</span>
            </button>

            <aside class="adrenaline-panel" id="adrenalinePanel" role="dialog" aria-modal="false" aria-hidden="true">
              <div class="ad-header">
                <div class="ad-title">Adrenaline</div>
                <div class="ad-views" role="tablist" aria-label="Adrenaline views">
                  <button class="ad-view is-active" data-view="new" role="tab" aria-selected="true">New</button>
                  <button class="ad-view" data-view="migrating" role="tab" aria-selected="false">Migrating</button>
                  <button class="ad-view" data-view="migrated" role="tab" aria-selected="false">Migrated</button>
                </div>
                <button class="ad-close" id="adrenalineClose" aria-label="Close">✕</button>
              </div>
              <div class="ad-body">
                <iframe id="adrenalineFrame"
                        title="Adrenaline table"
                        loading="lazy"
                        referrerpolicy="no-referrer"
                        src="Adrenaline-official.html?embed=1&view=new"></iframe>
              </div>
            </aside>
          </div>
          <!-- === /Adrenaline overlay slot === -->
        </section>

        <!-- RIGHT -->
        <aside class="nx-panel p-3">
          <div class="grid grid-cols-2 gap-2">
            <button id="buy-btn"  class="nx-btn nx-btn-green">Buy</button>
            <button id="sell-btn" class="nx-btn nx-btn-red">Sell</button>
          </div>

          <!-- Market/Limit toggle -->
          <div class="grid grid-cols-2 gap-2 mt-2">
            <button id="mkt-btn" class="nx-btn nx-btn-cyan">Market</button>
            <button id="lim-btn" class="nx-btn">Limit</button>
          </div>

          <div class="mt-3 space-y-2">
            <label class="text-sm" id="amt-label">Amount (SOL)</label>
            <input id="amt" class="nx-input tabnums" placeholder="0.0"/>
            
            <!-- Quick Amount Buttons - Buy Mode: SOL presets, Sell Mode: % buttons -->
            <div class="grid grid-cols-4 gap-2" id="quick-buy-btns">
              <button class="nx-btn text-xs" data-sol="0.005">0.005</button>
              <button class="nx-btn text-xs" data-sol="0.01">0.01</button>
              <button class="nx-btn text-xs" data-sol="0.015">0.015</button>
              <button class="nx-btn text-xs" data-sol="0.02">0.02</button>
            </div>
            <div class="grid grid-cols-4 gap-2 hidden" id="quick-sell-btns">
              <button class="nx-btn text-xs" data-pct="25">25%</button>
              <button class="nx-btn text-xs" data-pct="50">50%</button>
              <button class="nx-btn text-xs" data-pct="75">75%</button>
              <button class="nx-btn text-xs" data-pct="100">100%</button>
            </div>
            
            <!-- Expected Output -->
            <div id="output-display" class="hidden nx-panel p-2 text-sm">
              <div class="flex justify-between items-center">
                <span class="text-zinc-400">You'll receive:</span>
                <span id="output-amount" class="font-semibold text-emerald-400">—</span>
              </div>
              <div class="flex justify-between items-center mt-1 text-xs">
                <span class="text-zinc-400">Slippage:</span>
                <span id="price-impact" class="text-zinc-400">—</span>
              </div>
            </div>

            <div id="tp-sl" class="grid grid-cols-2 gap-2">
              <div>
                <label class="text-sm">TP %</label>
                <input id="tp" class="nx-input tabnums" placeholder=""/>
              </div>
              <div>
                <label class="text-sm">SL %</label>
                <input id="sl" class="nx-input tabnums" placeholder=""/>
              </div>
            </div>

            <div class="grid grid-cols-3 gap-2">
              <button class="nx-btn preset-btn" id="preset-1" data-preset="1">Preset 1</button>
              <button class="nx-btn preset-btn" id="preset-2" data-preset="2">Preset 2</button>
              <button class="nx-btn preset-btn" id="preset-3" data-preset="3">Preset 3</button>
            </div>

            <div id="preset-config" class="hidden">
              <div class="grid grid-cols-2 gap-2 mt-2">
                <div>
                  <label class="text-xs text-zinc-400">Fee (SOL)</label>
                  <input id="fee-sol" type="number" step="0.0001" min="0" class="nx-input tabnums" placeholder="0.001" />
                </div>
                <div>
                  <label class="text-xs text-zinc-400">MEV Protection</label>
                  <button id="mev-btn" class="nx-btn w-full">On</button>
                </div>
              </div>
              <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="preset-save"  class="nx-btn nx-btn-cyan">Save Preset</button>
                <button id="preset-reset" class="nx-btn">Reset Preset</button>
              </div>
            </div>

            <button id="submit-order" class="nx-btn nx-btn-cyan w-full text-base mt-2">Buy NEBULAX</button>
          </div>

          <div class="grid grid-cols-4 gap-3 mt-4 text-center text-xs" id="stat-boxes-container">
            <div class="nx-panel p-3 tabnums cursor-pointer hover:bg-gray-800/50 transition-colors" data-stat-box>
              <div class="text-zinc-400 text-[10px] mb-1">Bought</div>
              <div id="stat-bought" class="font-semibold">0 SOL</div>
              <div id="stat-bought-usd" class="text-[10px] text-zinc-500 mt-0.5">$0</div>
            </div>
            <div class="nx-panel p-3 tabnums cursor-pointer hover:bg-gray-800/50 transition-colors" data-stat-box>
              <div class="text-zinc-400 text-[10px] mb-1">Sold</div>
              <div id="stat-sold" class="font-semibold">0 SOL</div>
              <div id="stat-sold-usd" class="text-[10px] text-zinc-500 mt-0.5">$0</div>
            </div>
            <div class="nx-panel p-3 tabnums cursor-pointer hover:bg-gray-800/50 transition-colors" data-stat-box>
              <div class="text-zinc-400 text-[10px] mb-1">Holding</div>
              <div id="stat-holding" class="font-semibold">$0</div>
              <div id="stat-holding-tokens" class="text-[10px] text-zinc-500 mt-0.5">0 tokens</div>
            </div>
            <div class="nx-panel p-3 tabnums cursor-pointer hover:bg-gray-800/50 transition-colors" data-stat-box>
              <div class="text-zinc-400 text-[10px] mb-1">PnL</div>
              <div id="stat-pnl" class="font-semibold text-rose-400">$0</div>
              <div id="stat-pnl-pct" class="text-[10px] text-zinc-500 mt-0.5">0%</div>
            </div>
          </div>
          
          <!-- Token Holdings Display -->
          <div id="holdings-info" class="mt-2 text-xs text-zinc-500 text-center"></div>

          <div class="mt-3 mb-1 h-px bg-[var(--nx-border)]"></div>
          <div class="text-xs uppercase tracking-wide text-zinc-400 mb-2">Token Info</div>

          <div class="grid grid-cols-3 gap-3 text-center text-xs">
            <div class="nx-panel p-2"><div id="info-top10h">0%</div><span class="text-zinc-400">Top 10 H</span></div>
            <div class="nx-panel p-2"><div id="info-devh">0%</div><span class="text-zinc-400">Dev H</span></div>
            <div class="nx-panel p-2"><div id="info-snipersh">0%</div><span class="text-zinc-400">Snipers H</span></div>
            <div class="nx-panel p-2"><div id="info-insiders">0%</div><span class="text-zinc-400">Insiders</span></div>
            <div class="nx-panel p-2"><div id="info-bundlers">0%</div><span class="text-zinc-400">Bundlers</span></div>
            <div class="nx-panel p-2"><div id="info-lpburned">0%</div><span class="text-zinc-400">LP Burned</span></div>
            <div class="nx-panel p-2"><div id="info-holders">0</div><span class="text-zinc-400">Holders</span></div>
            <div class="nx-panel p-2"><div id="info-protraders">0</div><span class="text-zinc-400">Pro Traders</span></div>
            <div class="nx-panel p-2"><div id="info-dexpaid">None</div><span class="text-zinc-400">Dex Paid</span></div>
          </div>
        </section>
      </main>

      <footer class="mt-3 mb-4">
        <div class="nx-panel px-3 py-2 text-xs flex items-center justify-between">
          <div>&copy; <span id="year"></span> NebulaX v1.0 Beta</div>
          <div>Xpose Market</div>
        </div>
      </footer>
    </div>

    <!-- Alerts Modal -->
    <div id="alerts-modal" class="hidden fixed z-[2000] top-16 right-4 w-80 popover p-3">
      <div class="flex items-center justify-between mb-2">
        <div class="text-sm font-semibold">ENABLE ALERTS</div>
        <button id="alerts-close" class="nx-btn nx-btn-cyan px-2 py-1 text-xs">Close</button>
      </div>
      <div class="space-y-2 text-sm">
        <label class="flex items-center justify-between px-2 py-1 rounded-md hover:bg-[var(--nx-dark-2)]">
          <span>Whale buy</span><input type="checkbox" value="whale_buy">
        </label>
        <label class="flex items-center justify-between px-2 py-1 rounded-md hover:bg-[var(--nx-dark-2)]">
          <span>Whale sell</span><input type="checkbox" value="whale_sell">
        </label>
        <label class="flex items-center justify-between px-2 py-1 rounded-md hover:bg-[var(--nx-dark-2)]">
          <span>Volume +</span><input type="checkbox" value="volume_spike">
        </label>
        <label class="flex items-center justify-between px-2 py-1 rounded-md hover:bg-[var(--nx-dark-2)]">
          <span>Buys &gt; Sells</span><input type="checkbox" value="buys_sells_ratio">
        </label>
        <label class="flex items-center justify-between px-2 py-1 rounded-md hover:bg-[var(--nx-dark-2)]">
          <span>Holders +</span><input type="checkbox" value="holders_delta">
        </label>
        <label class="flex items-center justify-between px-2 py-1 rounded-md hover:bg-[var(--nx-dark-2)]">
          <span>LP change</span><input type="checkbox" value="lp_change">
        </label>
      </div>
      <button id="alerts-save" class="nx-btn nx-btn-cyan w-full mt-3">Save</button>
    </div>

    <!-- Wallet Modal Popup (from Trending) -->
    <div id="wallet-modal" class="modal-fx hidden">
      <div class="nx-panel w-[380px] max-w-[90vw] p-4">
        <div class="flex items-center justify-between mb-3">
          <div class="text-lg font-semibold">Wallet</div>
          <button class="nx-btn nx-btn-cyan px-2 py-1 text-xs" onclick="document.getElementById('wallet-modal').classList.add('hidden')">Close</button>
        </div>
        <div class="grid grid-cols-2 gap-2 text-sm mb-3">
          <div class="nx-panel p-3">
            <div class="text-xs text-zinc-400 mb-1">Total Balance</div>
            <div class="font-semibold text-base" id="wallet-total">0.000 SOL</div>
          </div>
          <div class="nx-panel p-3">
            <div class="text-xs text-zinc-400 mb-1">Available</div>
            <div class="font-semibold text-base" id="wallet-available">0.000 SOL</div>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-2 mb-3">
          <button id="wd-open" class="nx-btn">Withdraw</button>
          <button id="dp-open" class="nx-btn nx-btn-cyan">Deposit</button>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <button id="wallet-connect" class="nx-btn nx-btn-cyan">Connect</button>
          <button id="wallet-disconnect" class="nx-btn">Disconnect</button>
        </div>
      </div>
    </div>

    <!-- Deposit / Withdraw modals (from Trending) -->
    <div id="deposit" class="modal-fx hidden">
      <div class="nx-panel w-[360px] max-w-[90vw] p-3">
        <div class="flex items-center justify-between mb-2"><div class="font-semibold">Deposit</div><button class="nx-btn nx-btn-cyan px-2 py-1 text-xs" onclick="document.getElementById('deposit').classList.add('hidden')">Close</button></div>
        <div class="text-sm text-zinc-400 mb-3">Scan with your wallet or exchange app:</div>
        <!-- QR Code Container -->
        <div id="qr-code-container" class="flex justify-center mb-4 p-3 rounded-lg" style="background:#0f1a2e; border:1px solid var(--nx-border); border-radius:12px;">
          <div id="qr-code"></div>
        </div>
        <div class="text-sm text-zinc-400 mb-2">Or copy your wallet address:</div>
        <div class="nx-panel p-2 text-xs break-words" id="deposit-addr">Do7AJiNrJvFVGTUCw8XvVhRGVBVLTHcBvEnfi3K68gze</div>
        <button class="nx-btn nx-btn-cyan w-full mt-3" id="copy-deposit-btn">Copy Address</button>
      </div>
    </div>
    <div id="withdraw" class="modal-fx hidden">
      <div class="nx-panel w-[360px] max-w-[90vw] p-3">
        <div class="flex items-center justify-between mb-2"><div class="font-semibold">Withdraw</div><button class="nx-btn nx-btn-cyan px-2 py-1 text-xs" onclick="document.getElementById('withdraw').classList.add('hidden')">Close</button></div>
        <div class="space-y-2">
          <input class="nx-input" placeholder="Destination SOL address"/>
          <div class="grid grid-cols-3 gap-2">
            <input class="nx-input col-span-2" placeholder="Amount"/>
            <select class="nx-input"><option>SOL</option><option>USD</option></select>
          </div>
          <button class="nx-btn nx-btn-cyan w-full">Submit</button>
        </div>
      </div>
    </div>

    <!-- Wallet dropdown (kept for backwards compatibility) -->
    <div id="wallet-dd" class="hidden fixed z-[2000] top-16 right-3 w-80 popover p-3">
      <div class="text-sm font-semibold mb-1">Wallet <span class="text-[10px] text-zinc-400">mock</span></div>
      <div class="grid grid-cols-2 gap-2 text-sm mb-2">
        <div class="nx-panel p-2">Total<br/><strong>0.314 SOL</strong></div>
        <div class="nx-panel p-2">Available<br/><strong>0.214 SOL</strong></div>
      </div>
      <div class="grid grid-cols-2 gap-2">
        <button id="wd-open" class="nx-btn">Withdraw</button>
        <button id="dp-open" class="nx-btn nx-btn-cyan">Deposit</button>
      </div>
    </div>

    <script>
      if (window.lucide && typeof window.lucide.createIcons==='function'){ window.lucide.createIcons(); }
      document.getElementById('year').textContent = new Date().getFullYear();

      /* Back */
      document.getElementById('back-btn')?.addEventListener('click', (e)=>{ e.preventDefault(); history.back(); });

      /* Search handled by nx-search.js */

      /* ====== QR Code Generator for Deposit Modal ====== */
      function generateDepositQR(address) {
        const qrContainer = document.getElementById('qr-code');
        if (!qrContainer) return;
        
        // Clear existing QR code
        qrContainer.innerHTML = '';
        
        // Generate new QR code with Solana URI format
        // Format: solana:<address>
        const solanaURI = `solana:${address}`;
        
        try {
          new QRCode(qrContainer, {
            text: solanaURI,
            width: 200,
            height: 200,
            colorDark: '#00e6ff',
            colorLight: '#0f1a2e',
            correctLevel: QRCode.CorrectLevel.H
          });
          console.log('[QR Code] Generated for address:', address);
        } catch (error) {
          console.error('[QR Code] Generation failed:', error);
          qrContainer.innerHTML = '<div class="text-xs text-red-500">QR Code generation failed</div>';
        }
      }

      /* Attach to deposit button click */
      document.getElementById('dp-open')?.addEventListener('click', () => {
        const depositAddr = document.getElementById('deposit-addr')?.textContent || 'Do7AJiNrJvFVGTUCw8XvVhRGVBVLTHcBvEnfi3K68gze';
        setTimeout(() => {
          generateDepositQR(depositAddr);
        }, 100);
      });

      /* ====== Tabs ====== */
      const tabs=[...document.querySelectorAll('.tab')];
      const tabContent=document.getElementById('tab-content');
      const tabMap={
        orderbook: function() {
          // Trigger order book display refresh
          if (window.NXOrderBook && window.NXOrderBook.refreshDisplay) {
            window.NXOrderBook.refreshDisplay();
          }
        },
        trades:'Recent trades stream (mock).',
        holders:'Top holders snapshot (mock).',
        toptraders:'Top trader PnL leaderboard (mock).'
      };
      
      tabs.forEach(t=>t.addEventListener('click',()=>{ 
        tabs.forEach(x=>x.classList.remove('active')); 
        t.classList.add('active'); 
        
        const tabData = tabMap[t.dataset.tab];
        if (typeof tabData === 'function') {
          tabData(); // Execute function for dynamic tabs
        } else {
          tabContent.textContent = tabData || ''; // Set static content
        }
      }));
      
      // Initialize order book on page load if it's the active tab
      window.addEventListener('DOMContentLoaded', () => {
        const activeTab = document.querySelector('.tab.active');
        if (activeTab && activeTab.dataset.tab === 'orderbook') {
          if (window.NXOrderBook && window.NXOrderBook.refreshDisplay) {
            // Delay slightly to ensure everything is loaded
            setTimeout(() => window.NXOrderBook.refreshDisplay(), 500);
          }
        }
      });

      /* ====== Market/Limit ====== */
      const tpSl=document.getElementById('tp-sl');
      const mktBtn=document.getElementById('mkt-btn');
      const limBtn=document.getElementById('lim-btn');
      function setMode(mode){
        if(mode==='market'){ mktBtn.classList.add('nx-btn-cyan'); limBtn.classList.remove('nx-btn-cyan'); tpSl.style.display=''; }
        else{ limBtn.classList.add('nx-btn-cyan'); mktBtn.classList.remove('nx-btn-cyan'); tpSl.style.display='none'; }
      }
      mktBtn.addEventListener('click', ()=>setMode('market'));
      limBtn.addEventListener('click', ()=>setMode('limit'));
      setMode('market');

      /* ====== Presets ====== */
      const DEFAULTS={1:{amount:'0.1', feeSol:'0.001', mev:true}, 2:{amount:'0.25', feeSol:'0.001', mev:true}, 3:{amount:'0.5', feeSol:'0.001', mev:true}};
      const loadPresets=()=>{ try{ return JSON.parse(localStorage.getItem('nebula_presets')) || JSON.parse(JSON.stringify(DEFAULTS)); }catch{ return JSON.parse(JSON.stringify(DEFAULTS)); } };
      const savePresets=()=> localStorage.setItem('nebula_presets', JSON.stringify(PRESETS));
      let PRESETS=loadPresets();

      const presetBtns=[...document.querySelectorAll('.preset-btn')];
      const presetCfg=document.getElementById('preset-config');
      const feeInput=document.getElementById('fee-sol');
      const mevBtn=document.getElementById('mev-btn');
      const amtInput=document.getElementById('amt');
      const saveBtn=document.getElementById('preset-save');
      const resetBtn=document.getElementById('preset-reset');
      let activePreset=null;

      function openPreset(n){
        presetBtns.forEach(b=>b.classList.remove('active'));
        document.getElementById('preset-'+n).classList.add('active');
        activePreset=String(n);
        const p=PRESETS[activePreset];
        presetCfg.classList.remove('hidden');
        amtInput.value=p.amount; feeInput.value=p.feeSol; mevBtn.textContent=p.mev?'On':'Off';
      }
      function closePreset(){ presetBtns.forEach(b=>b.classList.remove('active')); activePreset=null; presetCfg.classList.add('hidden'); }

      presetBtns.forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const n=btn.dataset.preset;
          if(activePreset===n){ closePreset(); return; }
          openPreset(n);
        });
      });

      mevBtn.addEventListener('click', ()=>{ mevBtn.textContent = (mevBtn.textContent==='On')?'Off':'On'; });

      saveBtn.addEventListener('click', ()=>{
        if(!activePreset) return;
        PRESETS[activePreset] = { amount: amtInput.value || '0', feeSol: feeInput.value || '0.001', mev: (mevBtn.textContent==='On') };
        savePresets(); alert(`Saved Preset ${activePreset}`);
      });

      resetBtn.addEventListener('click', ()=>{
        if(!activePreset) return;
        PRESETS[activePreset] = {...DEFAULTS[activePreset]}; savePresets();
        const p=PRESETS[activePreset]; amtInput.value=p.amount; feeInput.value=p.feeSol; mevBtn.textContent=p.mev?'On':'Off';
        alert(`Reset Preset ${activePreset}`);
      });

      /* Buy/Sell & Submit - now handled by Jupiter integration below */
      // Removed old mock handlers - Jupiter script handles these

      /* Alerts popover */
      const aOpen=document.getElementById('alerts-open');
      const aModal=document.getElementById('alerts-modal');
      aOpen?.addEventListener('click', ()=>aModal.classList.remove('hidden'));
      document.getElementById('alerts-close')?.addEventListener('click', ()=>aModal.classList.add('hidden'));
      document.getElementById('alerts-save')?.addEventListener('click', ()=>{
        const checks=[...aModal.querySelectorAll('input[type="checkbox"]')].filter(c=>c.checked).map(c=>c.value);
        alert('Saved alerts: '+(checks.join(', ')||'none')+' (mock)'); aModal.classList.add('hidden');
      });

      /* ===== Wallet modal + modals (from Trending) ===== */
      const wBtn=document.getElementById('wallet-btn'); const wModal=document.getElementById('wallet-modal');
      // Update wallet display with real balance
      function updateWalletDisplay(){
        const balance = window.NXWallet?.getBalance?.();
        const sol = balance ? balance.toFixed(3) : '0.000';
        document.getElementById('wallet-total').textContent = sol + ' SOL';
        document.getElementById('wallet-available').textContent = sol + ' SOL';
      }
      wBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); updateWalletDisplay(); wModal.classList.remove('hidden'); });
      wModal?.addEventListener('click',(e)=>{ if(e.target===wModal) wModal.classList.add('hidden'); });
      document.getElementById('dp-open')?.addEventListener('click',()=>{ wModal.classList.add('hidden'); document.getElementById('deposit').classList.remove('hidden'); });
      document.getElementById('wd-open')?.addEventListener('click',()=>{ wModal.classList.add('hidden'); document.getElementById('withdraw').classList.remove('hidden'); });
      // Wallet connect/disconnect
      document.getElementById('wallet-connect')?.addEventListener('click',async()=>{ 
        const prov = (window.phantom?.solana) || window.solana;
        try { await prov?.connect?.(); } catch(e) { console.log('Connect cancelled'); }
      });
      document.getElementById('wallet-disconnect')?.addEventListener('click',async()=>{ 
        const prov = (window.phantom?.solana) || window.solana;
        try { await prov?.disconnect?.(); } catch(e) { console.log('Disconnect error'); }
      });
      // Deposit address copy
      const copyBtn = document.getElementById('copy-deposit-btn');
      const depositAddr = document.getElementById('deposit-addr');
      copyBtn?.addEventListener('click',()=>{ 
        const addr = depositAddr.textContent;
        navigator.clipboard.writeText(addr).then(()=>{ copyBtn.textContent='Copied!'; setTimeout(()=>{ copyBtn.textContent='Copy Address'; },2000); }); 
      });
      // Close modals on click outside
      document.getElementById('deposit')?.addEventListener('click',(e)=>{ if(e.target.id==='deposit') e.target.classList.add('hidden'); });
      document.getElementById('withdraw')?.addEventListener('click',(e)=>{ if(e.target.id==='withdraw') e.target.classList.add('hidden'); });
      // Listen for balance changes
      window.addEventListener('nebula:sol:changed',(e)=>{ if(!wModal.classList.contains('hidden')) updateWalletDisplay(); });
    </script>

    <!-- === Jupiter Swap V1 API Integration === -->
<script>
(async function(){
  // ===== JUPITER SWAP V1 API INTEGRATION =====
  // Uses api.jup.ag/swap/v1 endpoints with x-api-key header
  // Docs: https://station.jup.ag/docs/apis/swap-api
  
  const SOL_MINT = 'So11111111111111111111111111111111111111112'; // Native SOL
  const JUPITER_QUOTE_API = 'https://api.jup.ag/swap/v1/quote';
  const JUPITER_SWAP_API = 'https://api.jup.ag/swap/v1/swap';
  
  // Get API key - in production, use environment variable via build system
  // For now, using direct value since we're in browser (no process.env)
  const JUP_API_KEY = '233fe202-5da0-4296-903f-8ca65bd71b36';
  
  let currentQuote = null;
  let isSwapping = false;
  let isBuyMode = true; // true = buy token with SOL, false = sell token for SOL
  let tokenNotTradable = false; // Track if token can't be traded
  
  // Cache for token decimals
  const decimalsCache = new Map();
  
  // Toast notification system
  function showToast(type, title, message, duration = 5000) {
    // Create toast element
    const toast = document.createElement('div');
    toast.className = `nx-toast ${type}`;
    
    const icon = type === 'success' ? '✓' : '✕';
    
    toast.innerHTML = `
      <div class="nx-toast-icon">${icon}</div>
      <div class="nx-toast-content">
        <div class="nx-toast-title">${title}</div>
        <div class="nx-toast-message">${message}</div>
      </div>
      <button class="nx-toast-close">×</button>
    `;
    
    document.body.appendChild(toast);
    
    // Close button handler
    const closeBtn = toast.querySelector('.nx-toast-close');
    const close = () => {
      toast.classList.add('hiding');
      setTimeout(() => toast.remove(), 300);
    };
    closeBtn.addEventListener('click', close);
    
    // Auto-dismiss
    if (duration > 0) {
      setTimeout(close, duration);
    }
    
    return toast;
  }
  
  const amtInput = document.getElementById('amt');
  const outputDisplay = document.getElementById('output-display');
  const outputAmount = document.getElementById('output-amount');
  const priceImpact = document.getElementById('price-impact');
  const submitBtn = document.getElementById('submit-order');
  const buyBtn = document.getElementById('buy-btn');
  const sellBtn = document.getElementById('sell-btn');
  
  // Get current token mint from URL or localStorage fallback
  function getCurrentMint() {
    // First try URL
    const qp = new URLSearchParams(location.search);
    let mint = qp.get('mint') || '';
    
    if (mint) {
      console.log('[Jupiter] Using mint from URL:', mint);
      return mint;
    }
    
    // Fallback to localStorage
    try {
      const stored = localStorage.getItem('nebula_selected_coin');
      if (stored) {
        const coinData = JSON.parse(stored);
        mint = coinData.mint || '';
        if (mint) {
          console.log('[Jupiter] Using mint from localStorage:', mint);
          return mint;
        }
      }
    } catch (e) {
      console.error('[Jupiter] Error reading localStorage:', e);
    }
    
    // Last resort: check window.NX global
    if (window.NX?.mint) {
      console.log('[Jupiter] Using mint from window.NX:', window.NX.mint);
      return window.NX.mint;
    }
    
    console.warn('[Jupiter] No mint address found');
    return '';
  }
  
  // Make getCurrentMint globally accessible
  window.NX_getCurrentMint = getCurrentMint;
  
  // Get token decimals from on-chain mint data
  async function getTokenDecimals(mintAddress) {
    // Check cache first
    if (decimalsCache.has(mintAddress)) {
      return decimalsCache.get(mintAddress);
    }
    
    // SOL is always 9 decimals
    if (mintAddress === SOL_MINT) {
      decimalsCache.set(mintAddress, 9);
      return 9;
    }
    
    try {
      const connection = new solanaWeb3.Connection(window.NX_RPC);
      const mintPubkey = new solanaWeb3.PublicKey(mintAddress);
      
      // Use getParsedAccountInfo to get mint data
      const info = await connection.getParsedAccountInfo(mintPubkey);
      
      if (info && info.value && info.value.data && info.value.data.parsed) {
        const decimals = info.value.data.parsed.info.decimals;
        console.log(`[Jupiter] Fetched decimals for ${mintAddress.substring(0, 8)}...: ${decimals}`);
        decimalsCache.set(mintAddress, decimals);
        return decimals;
      }
      
      // Fallback to 9 if we can't determine
      console.warn(`[Jupiter] Could not determine decimals for ${mintAddress}, defaulting to 9`);
      return 9;
    } catch (error) {
      console.error(`[Jupiter] Error fetching decimals for ${mintAddress}:`, error);
      // Fallback to 9
      return 9;
    }
  }
  
  // Build raw amount with correct decimals
  async function buildRawAmount(uiAmount, mintAddress) {
    const decimals = await getTokenDecimals(mintAddress);
    const factor = Math.pow(10, decimals);
    const raw = Math.floor(parseFloat(uiAmount) * factor);
    return raw.toString();
  }
  
  // Format token amounts with proper decimals
  function formatTokenAmount(amount, decimals = 9) {
    const num = parseFloat(amount) / Math.pow(10, decimals);
    if (num === 0) return '0';
    if (num < 0.000001) return num.toFixed(9);
    if (num < 0.01) return num.toFixed(8);
    if (num < 1) return num.toFixed(6);
    if (num < 1000) return num.toFixed(4);
    return num.toLocaleString(undefined, { maximumFractionDigits: 2 });
  }
  
  // Fetch quote from Jupiter Swap V1 API with authentication
  async function fetchQuote(inputMint, outputMint, uiAmount, retries = 2) {
    try {
      // Get correct decimals for the input token
      const amountRaw = await buildRawAmount(uiAmount, inputMint);
      
      if (!amountRaw || amountRaw === '0') return null;
      
      const params = new URLSearchParams({
        inputMint,
        outputMint,
        amount: amountRaw,
        slippageBps: '50', // 0.5% slippage
        onlyDirectRoutes: 'false',
        asLegacyTransaction: 'false'
      });
      
      console.log('[Jupiter Swap V1] Fetching quote...', params.toString());
      
      const response = await fetch(`${JUPITER_QUOTE_API}?${params}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': JUP_API_KEY
        }
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        let errorData;
        try {
          errorData = JSON.parse(errorText);
        } catch (e) {
          errorData = { error: errorText };
        }
        
        // Check for permanent errors (don't retry these)
        if (errorData.errorCode === 'TOKEN_NOT_TRADABLE') {
          console.warn('[Jupiter Swap] This token is not tradable via Jupiter routing:', errorData.error);
          tokenNotTradable = true;
          disableSwapUI('This token is not currently tradable through Jupiter. You can still view your holdings and chart.');
          return null;
        }
        
        if (errorData.errorCode === 'NO_ROUTES_FOUND') {
          console.warn('[Jupiter Swap] No routes found for this token pair');
          tokenNotTradable = true;
          disableSwapUI('No swap routes available for this token pair.');
          return null;
        }
        
        console.error('[Jupiter Swap V1] Quote failed:', response.status, errorText.substring(0, 300));
        throw new Error(`Quote failed: ${response.status}`);
      }
      
      const quote = await response.json();
      
      // Check for errors in response
      if (quote.error) {
        // Check for permanent routing errors
        if (quote.errorCode === 'TOKEN_NOT_TRADABLE' || quote.errorCode === 'NO_ROUTES_FOUND') {
          console.warn('[Jupiter Swap] Routing error:', quote.error);
          tokenNotTradable = true;
          disableSwapUI(quote.error);
          return null;
        }
        
        console.error('[Jupiter Swap V1] Quote error:', quote.error);
        throw new Error(quote.error);
      }
      
      console.log('[Jupiter Swap V1] Quote received:', {
        inAmount: quote.inAmount,
        outAmount: quote.outAmount,
        priceImpactPct: quote.priceImpactPct
      });
      
      // Clear tokenNotTradable flag if we got a quote
      tokenNotTradable = false;
      
      return quote;
    } catch (error) {
      console.error('[Jupiter Swap V1] Quote error:', error.message);
      
      // Only retry for transient errors (network, 5xx)
      const isTransientError = error.message.includes('Failed to fetch') || 
                               error.message.includes('503') || 
                               error.message.includes('502');
      
      if (retries > 0 && isTransientError) {
        const delay = (3 - retries) * 500;
        console.log(`[Jupiter Swap V1] Retrying in ${delay}ms... (${retries} retries left)`);
        await new Promise(resolve => setTimeout(resolve, delay));
        return fetchQuote(inputMint, outputMint, uiAmount, retries - 1);
      }
      
      return null;
    }
  }
  
  // Disable swap UI with error message
  function disableSwapUI(message) {
    if (submitBtn) {
      submitBtn.disabled = true;
      submitBtn.classList.remove('nx-btn-cyan');
      submitBtn.classList.add('opacity-50', 'cursor-not-allowed');
    }
    
    // Show error message
    if (outputDisplay && outputAmount) {
      outputAmount.textContent = message;
      outputAmount.className = 'font-semibold text-amber-400 text-xs';
      priceImpact.textContent = '';
      outputDisplay.classList.remove('hidden');
    }
  }
  
  // Re-enable swap UI
  function enableSwapUI() {
    if (submitBtn) {
      submitBtn.disabled = false;
      submitBtn.classList.add('nx-btn-cyan');
      submitBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    }
    tokenNotTradable = false;
  }
  
  // Update output display with quote info
  async function updateOutputDisplay(quote) {
    if (!quote) {
      outputDisplay.classList.add('hidden');
      return;
    }
    currentQuote = quote;
    // Get token decimals - use 6 as default for most tokens, 9 for SOL
    const decimals = isBuyMode ? 6 : 9; // When buying tokens, assume 6 decimals; when selling, output is SOL (9)
    const outAmount = parseFloat(quote.outAmount) / Math.pow(10, decimals);
    const minOutAmount = parseFloat(quote.outAmountSol || quote.minOutAmount || quote.outAmount) / Math.pow(10, decimals);
    // Calculate slippage percentage
    const slippagePct = outAmount > 0 ? ((outAmount - minOutAmount) / outAmount * 100).toFixed(2) : 0;
    // Round to nearest 100 for large amounts (common for cheap tokens)
    let displayAmount;
    if (outAmount > 10000) {
      displayAmount = (Math.round(outAmount / 100) * 100).toLocaleString(undefined, { maximumFractionDigits: 0 });
    } else if (outAmount > 1000) {
      displayAmount = outAmount.toLocaleString(undefined, { maximumFractionDigits: 0 });
    } else if (outAmount > 1) {
      displayAmount = outAmount.toLocaleString(undefined, { maximumFractionDigits: 2 });
    } else {
      displayAmount = outAmount.toFixed(6);
    }
    // Get output token symbol - for buying, it's the token we're getting; for selling, it's SOL
    let outputSymbol = 'SOL';
    if (isBuyMode) {
      outputSymbol = window.NX?.base || 'TOKEN';
    }
    // When selling, outputSymbol stays as 'SOL'
    // Jupiter Swap V1 returns priceImpactPct directly
    const impact = parseFloat(quote.priceImpactPct) || 0;
    const impactColor = impact > 5 ? 'text-rose-400' : impact > 1 ? 'text-amber-400' : 'text-emerald-400';

    // --- SOL/USD price fetch and USD value calculation ---
    let solPrice = window.NX?.solPrice;
    if (!solPrice) {
      try {
        const solPriceRes = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
        if (solPriceRes.ok) {
          const solPriceData = await solPriceRes.json();
          solPrice = solPriceData?.solana?.usd || 0;
          window.NX = window.NX || {};
          window.NX.solPrice = solPrice;
        }
      } catch (e) {
        solPrice = 0;
      }
    }
    let usdValue = 0;
    if (!isBuyMode) {
      // Selling token for SOL, so outAmount is in SOL
      usdValue = solPrice ? outAmount * solPrice : 0;
    } else {
      // Buying token, show USD value of input SOL (amtInput.value)
      const inputSol = parseFloat(amtInput.value) || 0;
      usdValue = solPrice ? inputSol * solPrice : 0;
    }
    let usdDisplay = '';
    if (solPrice && usdValue > 0) {
      usdDisplay = ` <span style="color:#a5ffea;font-size:0.95em;">($${usdValue.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2})})</span>`;
    }
    outputAmount.innerHTML = `${displayAmount} ${outputSymbol}${!isBuyMode ? usdDisplay : ''}`;
    // For buy mode, show USD value next to input field as well (optional)
    if (isBuyMode && usdDisplay && amtInput) {
      // Optionally, you could show the USD value in a separate element if desired
      outputAmount.innerHTML += ` <span style=\"color:#a5ffea;font-size:0.95em;\">(${amtInput.value ? '$'+(parseFloat(amtInput.value)*solPrice).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}) : ''})</span>`;
    }
    priceImpact.textContent = `Slippage: ${slippagePct}%`;
    priceImpact.className = `text-xs ${impactColor}`;
    outputDisplay.classList.remove('hidden');
  }
  
  // Show error in output display
  function showOutputError(message) {
    outputAmount.textContent = message;
    outputAmount.className = 'font-semibold text-rose-400 text-xs';
    priceImpact.textContent = '—';
    outputDisplay.classList.remove('hidden');
  }
  
  // Debounced quote fetcher
  let quoteTimeout;
  async function handleAmountChange() {
    clearTimeout(quoteTimeout);
    
    const amount = amtInput.value?.trim();
    if (!amount || parseFloat(amount) <= 0) {
      outputDisplay.classList.add('hidden');
      currentQuote = null;
      enableSwapUI(); // Re-enable in case it was disabled
      return;
    }
    
    const mint = getCurrentMint();
    if (!mint) {
      console.warn('[Jupiter Swap V1] No token mint found');
      return;
    }
    
    // Re-enable UI in case it was disabled from previous error
    if (tokenNotTradable) {
      enableSwapUI();
    }
    
    // Show loading state
    outputAmount.textContent = 'Loading...';
    outputAmount.className = 'font-semibold text-emerald-400';
    priceImpact.textContent = '...';
    outputDisplay.classList.remove('hidden');
    
    quoteTimeout = setTimeout(async () => {
      const inputMint = isBuyMode ? SOL_MINT : mint;
      const outputMint = isBuyMode ? mint : SOL_MINT;
      const quote = await fetchQuote(inputMint, outputMint, amount);
      
      if (quote) {
        updateOutputDisplay(quote);
        enableSwapUI(); // Make sure UI is enabled on success
      } else if (!tokenNotTradable) {
        // Only show generic error if not TOKEN_NOT_TRADABLE (already handled in fetchQuote)
        const tokenSymbol = window.NX?.base || 'TOKEN';
        if (isBuyMode) {
          showOutputError(`No route found for ${tokenSymbol}`);
        } else {
          showOutputError(`No route to sell ${tokenSymbol}`);
        }
      }
    }, 500);
  }
  
  // Execute swap using Jupiter Swap V1 API
  async function executeSwap() {
    if (isSwapping || !currentQuote) {
      if (!currentQuote) {
        showToast('error', 'No Quote Available', 'Please wait for quote to load or check if token has liquidity on Jupiter');
      }
      return;
    }
    
    // Check wallet connection
    if (!window.NXWallet?.isConnected()) {
      showToast('error', 'Wallet Not Connected', 'Please connect your wallet first');
      return;
    }
    
    const mint = getCurrentMint();
    if (!mint) {
      showToast('error', 'Token Not Found', 'Token mint address not found');
      return;
    }
    
    isSwapping = true;
    const originalText = submitBtn.textContent;
    submitBtn.textContent = 'Getting transaction...';
    submitBtn.disabled = true;
    
    try {
      // Get wallet provider
      const provider = window.phantom?.solana || window.solana;
      if (!provider) throw new Error('Wallet provider not found');
      
      const publicKey = provider.publicKey;
      if (!publicKey) throw new Error('Wallet not connected');
      
      // Step 1: Get swap transaction from Jupiter Swap V1 API with authentication
      console.log('[Jupiter Swap V1] Getting swap transaction...');
      const swapResponse = await fetch(JUPITER_SWAP_API, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': JUP_API_KEY
        },
        body: JSON.stringify({
          quoteResponse: currentQuote,
          userPublicKey: publicKey.toString(),
          wrapAndUnwrapSol: true,
          dynamicComputeUnitLimit: true,
          prioritizationFeeLamports: 'auto' // Auto priority fee
        })
      });
      
      if (!swapResponse.ok) {
        const errorText = await swapResponse.text();
        throw new Error(`Failed to get swap transaction: ${errorText}`);
      }
      
      const swapData = await swapResponse.json();
      
      if (swapData.error) {
        throw new Error(swapData.error);
      }
      
      // Step 2: Deserialize and sign the transaction
      console.log('[Jupiter Swap V1] Deserializing transaction...');
      submitBtn.textContent = 'Sign in wallet...';
      
      const swapTransactionBuf = Uint8Array.from(atob(swapData.swapTransaction), c => c.charCodeAt(0));
      const transaction = solanaWeb3.VersionedTransaction.deserialize(swapTransactionBuf);
      
      console.log('[Jupiter Swap V1] Signing transaction...');
      const signedTransaction = await provider.signTransaction(transaction);
      
      // Step 3: Send the signed transaction to the network
      console.log('[Jupiter Swap V1] Sending transaction to network...');
      submitBtn.textContent = 'Sending...';
      
      const connection = new solanaWeb3.Connection(window.NX_RPC);
      const rawTransaction = signedTransaction.serialize();
      
      const txid = await connection.sendRawTransaction(rawTransaction, {
        skipPreflight: true,
        maxRetries: 3
      });
      
      console.log('[Jupiter Swap V1] Transaction sent:', txid);
      submitBtn.textContent = 'Confirming...';
      
      // Step 4: Wait for confirmation
      const confirmation = await connection.confirmTransaction(txid, 'confirmed');
      
      if (confirmation.value.err) {
        throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
      }
      console.log('[Jupiter Swap V1] Transaction confirmed:', txid);
      
      // Log to order book
      const tokenSymbol = window.NX?.base || 'TOKEN';
      const orderMint = getCurrentMint();
      const userPublicKey = window.NXWallet?.publicKey;
      
      // Calculate actual amounts from quote using correct decimals
      const tokenDecimals = await getTokenDecimals(orderMint);
      const solDecimals = 9; // SOL is always 9
      
      const tokenAmount = parseFloat(
        isBuyMode ? currentQuote.outAmount : currentQuote.inAmount
      ) / Math.pow(10, tokenDecimals);
      
      const solAmount = parseFloat(
        isBuyMode ? currentQuote.inAmount : currentQuote.outAmount
      ) / Math.pow(10, solDecimals);
      
      // Calculate actual price paid (SOL per token)
      const pricePerToken = tokenAmount > 0 ? (solAmount / tokenAmount) : 0;
      const tokenPriceUSD = window.NX?.coinMarketData?.price || 0;
      const solPriceAtTrade = window.NX?.solPrice || 0;
      const currentMC = window.NX?.coinMarketData?.mcap || 0;
      
      // Lock USD values AND market cap at trade time (OPTION A - for accurate historical tracking)
      const tradeValueUSD = solAmount * solPriceAtTrade; // Total USD value of trade
      const tokenPriceUSDLocked = pricePerToken * solPriceAtTrade; // Token price in USD
      
      // Lock market cap at this price point (so it never changes)
      let marketCapAtTrade = 0;
      if (currentMC > 0 && tokenPriceUSD > 0) {
        marketCapAtTrade = (tokenPriceUSDLocked / tokenPriceUSD) * currentMC;
      }
      
      console.log(`[OrderBook] Logging trade: ${isBuyMode ? 'BUY' : 'SELL'} ${tokenAmount} ${tokenSymbol} for ${solAmount} SOL ($${tradeValueUSD.toFixed(2)}) at SOL=$${solPriceAtTrade}, MC=$${formatNumber(marketCapAtTrade)}`);
      
      logTradeToOrderBook({
        tokenMint: orderMint,
        tokenSymbol: tokenSymbol,
        type: isBuyMode ? 'buy' : 'sell',
        tokenAmount: tokenAmount,
        solAmount: solAmount,
        pricePerToken: pricePerToken, // SOL per token
        priceUSD: tokenPriceUSD, // Current token price in USD (for reference)
        solPriceAtTrade: solPriceAtTrade, // LOCKED: SOL price at trade time
        tradeValueUSD: tradeValueUSD, // LOCKED: Total USD value at trade time
        tokenPriceUSDLocked: tokenPriceUSDLocked, // LOCKED: Token USD price at trade time
        marketCapAtTrade: marketCapAtTrade, // LOCKED: Market cap at trade time (never changes)
        txid: txid,
        wallet: userPublicKey.toString()
        // Ready for Supabase: All fields needed for historical accuracy
      });
      
      // Clear inputs and refresh all balances
      amtInput.value = '';
      outputDisplay.classList.add('hidden');
      currentQuote = null;
      
      // Refresh wallet SOL balance
      if (window.NXWallet?.refreshBalance) {
        await window.NXWallet.refreshBalance(true);
      }
      
      // Trigger holdings refresh (token balance and stats)
      console.log('[Jupiter Swap V1] Triggering holdings refresh...');
      window.dispatchEvent(new CustomEvent('jupiter:swap:complete', { detail: { txid } }));
      
      // Show success toast with transaction link
      const shortTx = `${txid.slice(0, 8)}...${txid.slice(-8)}`;
      showToast(
        'success',
        'Swap Successful!',
        `Transaction confirmed: <a href="https://solscan.io/tx/${txid}" target="_blank" class="nx-toast-link">${shortTx}</a>`,
        8000
      );
      
    } catch (error) {
      console.error('[Jupiter Swap V1] Swap failed:', error);
      
      // Determine if user rejected or actual error
      if (error.message?.includes('User rejected') || error.code === 4001) {
        showToast('error', 'Transaction Cancelled', 'You rejected the transaction', 3000);
      } else {
        showToast('error', 'Swap Failed', error.message, 5000);
      }
    } finally {
      isSwapping = false;
      submitBtn.textContent = originalText;
      submitBtn.disabled = false;
    }
  }
  
  // ===== UTILITY FUNCTIONS =====
  // Format large numbers (must be defined before order book functions)
  function formatNumber(num, isTokenQty = false) {
    if (!num || isNaN(num)) return '0.00';
    const absNum = Math.abs(num);
    
    // Special formatting for token quantities
    if (isTokenQty) {
      if (absNum >= 1e9) return (num / 1e9).toFixed(2) + 'B';
      if (absNum >= 1e6) return (num / 1e6).toFixed(2) + 'M';
      if (absNum >= 1e3) return (num / 1e3).toFixed(2) + 'K';
      if (absNum >= 1) return num.toFixed(2);
      return num.toFixed(4);
    }
    
    // Standard number formatting (for USD values)
    if (absNum >= 1e9) return (num / 1e9).toFixed(2) + 'B';
    if (absNum >= 1e6) return (num / 1e6).toFixed(2) + 'M';
    if (absNum >= 1e3) return (num / 1e3).toFixed(2) + 'K';
    if (absNum < 0.01 && absNum > 0) return num.toFixed(5);
    return num.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 });
  }
  
  // Make formatNumber globally accessible for other script blocks
  window.formatNumber = formatNumber;
  
  // ===== ORDER BOOK SYSTEM =====
  /*
   * SUPABASE INTEGRATION PATHWAY:
   * 
   * Current: localStorage (single-device, 1000 trade limit)
   * Future: Supabase (cross-device, unlimited, analytics)
   * 
   * Database Schema (orders table):
   * - id: uuid (primary key)
   * - created_at: timestamptz (auto)
   * - timestamp: bigint (trade time in ms)
   * - token_mint: text (token address)
   * - token_symbol: text (token symbol)
   * - type: text ('buy' or 'sell')
   * - token_amount: numeric (quantity of tokens)
   * - sol_amount: numeric (quantity of SOL)
   * - price_per_token: numeric (SOL per token)
   * - price_usd: numeric (reference token price)
   * - sol_price_at_trade: numeric (LOCKED SOL price)
   * - trade_value_usd: numeric (LOCKED total USD value)
   * - token_price_usd_locked: numeric (LOCKED token USD price)
   * - txid: text (Solana transaction ID)
   * - wallet: text (user wallet address)
   * 
   * Migration Steps:
   * 1. Create Supabase project + orders table with above schema
   * 2. Add @supabase/supabase-js to project
   * 3. Replace localStorage calls with Supabase queries
   * 4. Add user authentication (wallet-based)
   * 5. Migrate existing localStorage data to Supabase
   * 6. Add analytics queries (top tokens, PnL over time, etc.)
   */
  const ORDER_BOOK_KEY = 'nebulax_order_book';
  
  // Make order book functions globally accessible
  window.NXOrderBook = {
    ORDER_BOOK_KEY: ORDER_BOOK_KEY,
    logTrade: logTradeToOrderBook,
    getTokenTrades: getTokenTrades,
    getUserTokenTrades: getUserTokenTrades,
    calculateUserStats: calculateUserStats,
    refreshDisplay: refreshOrderBookDisplay
  };
  
  // Log trade to order book
  function logTradeToOrderBook(trade) {
    try {
      const orderBook = JSON.parse(localStorage.getItem(ORDER_BOOK_KEY) || '[]');
      
      const tradeEntry = {
        timestamp: Date.now(),
        tokenMint: trade.tokenMint,
        tokenSymbol: trade.tokenSymbol,
        type: trade.type, // 'buy' or 'sell'
        tokenAmount: trade.tokenAmount,
        solAmount: trade.solAmount,
        price: trade.price,
        txid: trade.txid,
        wallet: trade.wallet
      };
      
      orderBook.unshift(tradeEntry); // Add to beginning
      
      // Keep last 1000 trades
      if (orderBook.length > 1000) orderBook.pop();
      
      localStorage.setItem(ORDER_BOOK_KEY, JSON.stringify(orderBook));
      console.log('[OrderBook] Trade logged:', tradeEntry);
      
      // Refresh order book display if on current token
      const currentMint = (window.NX_getCurrentMint && window.NX_getCurrentMint()) || '';
      if (currentMint === trade.tokenMint) {
        refreshOrderBookDisplay();
      }
    } catch (error) {
      console.error('[OrderBook] Failed to log trade:', error);
    }
  }
  
  // Get trades for specific token
  function getTokenTrades(tokenMint) {
    try {
      const orderBook = JSON.parse(localStorage.getItem(ORDER_BOOK_KEY) || '[]');
      return orderBook.filter(trade => trade.tokenMint === tokenMint);
    } catch (error) {
      console.error('[OrderBook] Failed to get token trades:', error);
      return [];
    }
  }
  
  // Get user's trades for specific token
  function getUserTokenTrades(tokenMint, wallet) {
    try {
      const orderBook = JSON.parse(localStorage.getItem(ORDER_BOOK_KEY) || '[]');
      return orderBook.filter(trade => 
        trade.tokenMint === tokenMint && 
        trade.wallet === wallet
      );
    } catch (error) {
      console.error('[OrderBook] Failed to get user trades:', error);
      return [];
    }
  }
  
  // Calculate user stats from trade history
  function calculateUserStats(tokenMint, wallet) {
    const trades = getUserTokenTrades(tokenMint, wallet);
    
    let totalBought = 0;
    let totalSold = 0;
    let solSpent = 0;
    let solReceived = 0;
    let usdSpent = 0; // LOCKED USD values
    let usdReceived = 0; // LOCKED USD values
    
    trades.forEach(trade => {
      if (trade.type === 'buy') {
        totalBought += trade.tokenAmount;
        solSpent += trade.solAmount;
        // Use locked USD value from trade time, fallback to 220 SOL price estimate
        usdSpent += trade.tradeValueUSD || (trade.solAmount * (trade.solPriceAtTrade || window.NX?.solPrice || 220));
      } else {
        totalSold += trade.tokenAmount;
        solReceived += trade.solAmount;
        // Use locked USD value from trade time, fallback to 220 SOL price estimate
        usdReceived += trade.tradeValueUSD || (trade.solAmount * (trade.solPriceAtTrade || window.NX?.solPrice || 220));
      }
    });
    
    const pnl = solReceived - solSpent;
    const pnlUSD = usdReceived - usdSpent; // Accurate PnL using locked values
    
    return {
      bought: totalBought,
      sold: totalSold,
      pnl: pnl,
      solSpent: solSpent,
      solReceived: solReceived,
      boughtUSD: usdSpent, // LOCKED at trade time
      soldUSD: usdReceived, // LOCKED at trade time
      pnlUSD: pnlUSD // Accurate based on locked values
    };
  }
  
  // Format time ago
  function timeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - timestamp) / 1000);
    
    if (seconds < 60) return `${seconds}s ago`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    return `${Math.floor(seconds / 86400)}d ago`;
  }
  
  // Utility: Repair corrupted trade data in localStorage
  // Run from console: window.repairTrade(txid, { tokenAmount: 1800, solPriceAtTrade: 220, tradeValueUSD: 1.10 })
  window.repairTrade = function(txid, updates) {
    const ORDER_BOOK_KEY = 'nebulax_order_book';
    let trades = JSON.parse(localStorage.getItem(ORDER_BOOK_KEY) || '[]');
    const idx = trades.findIndex(t => t.txid === txid);
    if (idx === -1) {
      console.error('[RepairTrade] Trade not found with txid:', txid);
      return false;
    }
    console.log('[RepairTrade] Before:', trades[idx]);
    Object.assign(trades[idx], updates);
    console.log('[RepairTrade] After:', trades[idx]);
    localStorage.setItem(ORDER_BOOK_KEY, JSON.stringify(trades));
    console.log('[RepairTrade] Saved! Refresh page to see changes.');
    return true;
  };
  
  // Utility: List all trades for inspection
  window.listTrades = function() {
    const ORDER_BOOK_KEY = 'nebulax_order_book';
    const trades = JSON.parse(localStorage.getItem(ORDER_BOOK_KEY) || '[]');
    console.table(trades.map(t => ({
      time: new Date(t.timestamp).toLocaleString(),
      type: t.type,
      symbol: t.tokenSymbol,
      qty: t.tokenAmount,
      sol: t.solAmount,
      usdValue: t.tradeValueUSD,
      solPrice: t.solPriceAtTrade,
      txid: t.txid?.slice(0,8) + '...'
    })));
    return trades;
  };
  
  // Refresh order book display
  function refreshOrderBookDisplay() {
    const mint = (window.NX_getCurrentMint && window.NX_getCurrentMint()) || '';
    if (!mint) {
      console.warn('[OrderBook] No mint address found');
      return;
    }
    
    const contentArea = document.getElementById('tab-content');
    if (!contentArea) {
      console.warn('[OrderBook] Could not find tab content area');
      return;
    }
    
    // Check if order book tab is active
    const orderBookTab = document.querySelector('.tab[data-tab="orderbook"]');
    if (!orderBookTab || !orderBookTab.classList.contains('active')) {
      return; // Don't refresh if not on order book tab
    }
    
    const allTrades = getTokenTrades(mint);
    
    if (allTrades.length === 0) {
      contentArea.innerHTML = `
        <div class="p-6 text-center text-gray-400">
          <p class="text-base">📊 No trades yet for this token</p>
          <p class="text-sm mt-2 opacity-70">Your trades will appear here after you buy or sell</p>
        </div>
      `;
      return;
    }
    
    // Calculate aggregated trade statistics
    const tradeStats = calculateTradeStatistics(allTrades);
    
    // Get user stats for accurate PnL calculation
    const userStats = calculateUserStats(mint, window.NX?.pubkey?.toString());
    
    // Generate table rows with enhanced data
    const rows = allTrades.slice(0, 100).map(trade => {
      const isBuy = trade.type === 'buy';
      const pricePerToken = trade.pricePerToken || (trade.tokenAmount > 0 ? (trade.solAmount / trade.tokenAmount) : 0);
      
      // Use LOCKED values from trade time (Option A) - total trade value
      const tradeValueUSD = trade.tradeValueUSD || (trade.solAmount * (trade.solPriceAtTrade || window.NX?.solPrice || 0));
      
      return `
        <tr class="hover:bg-gray-800/30 transition-colors">
          <td class="p-2 text-gray-400 text-xs whitespace-nowrap">${formatTimestamp(trade.timestamp)}</td>
          <td class="p-2">
            <span class="px-2 py-0.5 rounded text-xs font-bold ${
              isBuy 
                ? 'bg-emerald-500/20 text-emerald-400 border border-emerald-500/30' 
                : 'bg-rose-500/20 text-rose-400 border border-rose-500/30'
            }">
              ${isBuy ? '🟢 BUY' : '🔴 SELL'}
            </span>
          </td>
          <td class="p-2 text-right">
            <div class="font-mono text-white">${formatNumber(trade.tokenAmount, true)}</div>
            <div class="text-xs text-gray-500">${trade.tokenSymbol || 'TOKEN'}</div>
          </td>
          <td class="p-2 text-right">
            <div class="font-mono text-white">${trade.solAmount.toFixed(4)}</div>
            <div class="text-xs text-gray-500">SOL</div>
          </td>
          <td class="p-2 text-right">
            <div class="font-mono text-cyan-400">${pricePerToken.toFixed(9)}</div>
            <div class="text-xs text-gray-500">SOL/Token</div>
          </td>
          <td class="p-2 text-right">
            <div class="font-mono text-white">$${formatNumber(tradeValueUSD)}</div>
            <div class="text-xs text-gray-500">USD Value</div>
          </td>
          ${!isBuy ? calculatePnLCell(trade, tradeStats.avgEntry, tradeStats.avgEntryMC, userStats) : '<td class="p-2 text-center text-gray-600">—</td>'}
        </tr>
      `;
    }).join('');
    
    contentArea.innerHTML = `
      <div class="space-y-3">
        <!-- Summary Stats Card -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-2 p-3 bg-gray-900/50 rounded-lg border border-gray-700">
          <div>
            <div class="text-xs text-gray-400 mb-1">Total Buys</div>
            <div class="text-emerald-400 font-bold">${tradeStats.totalBuys}</div>
            <div class="text-xs text-gray-500">${formatNumber(tradeStats.totalBought, true)} tokens</div>
          </div>
          <div>
            <div class="text-xs text-gray-400 mb-1">Total Sells</div>
            <div class="text-rose-400 font-bold">${tradeStats.totalSells}</div>
            <div class="text-xs text-gray-500">${formatNumber(tradeStats.totalSold, true)} tokens</div>
          </div>
          <div>
            <div class="text-xs text-gray-400 mb-1">Avg Entry</div>
            <div class="text-cyan-400 font-bold text-sm">${tradeStats.avgEntry > 0.001 ? tradeStats.avgEntry.toFixed(6) : tradeStats.avgEntry.toFixed(9)} SOL</div>
            <div class="text-xs text-gray-500">$${formatNumber(tradeStats.avgEntryMC)} MC</div>
          </div>
          <div>
            <div class="text-xs text-gray-400 mb-1">Avg Exit</div>
            <div class="text-cyan-400 font-bold text-sm">${tradeStats.avgExit > 0 ? (tradeStats.avgExit > 0.001 ? tradeStats.avgExit.toFixed(6) : tradeStats.avgExit.toFixed(9)) + ' SOL' : '—'}</div>
            <div class="text-xs text-gray-500">${tradeStats.avgExit > 0 ? '$' + formatNumber(tradeStats.avgExitMC) + ' MC' : 'No sells yet'}</div>
          </div>
        </div>
        
        <!-- Trade History Table -->
        <div class="overflow-auto rounded-lg border border-gray-700" style="max-height: 500px;">
          <table class="w-full text-sm">
            <thead class="sticky top-0 bg-gray-900 border-b border-gray-700 z-10">
              <tr class="text-gray-400 text-xs uppercase tracking-wide">
                <th class="p-2 text-left font-semibold">Time</th>
                <th class="p-2 text-left font-semibold">Type</th>
                <th class="p-2 text-right font-semibold">Quantity</th>
                <th class="p-2 text-right font-semibold">SOL</th>
                <th class="p-2 text-right font-semibold">Price</th>
                <th class="p-2 text-right font-semibold">Value</th>
                <th class="p-2 text-right font-semibold">PnL</th>
              </tr>
            </thead>
            <tbody class="divide-y divide-gray-800">
              ${rows}
            </tbody>
          </table>
        </div>
        
        <div class="text-xs text-gray-500 text-center">
          Showing ${Math.min(allTrades.length, 100)} of ${allTrades.length} trade${allTrades.length !== 1 ? 's' : ''}
        </div>
      </div>
    `;
    
    console.log('[OrderBook] Display refreshed with', allTrades.length, 'trades');
  }
  
  // Calculate aggregated statistics from trades
  function calculateTradeStatistics(trades) {
    let totalBuys = 0;
    let totalSells = 0;
    let totalBought = 0;
    let totalSold = 0;
    let totalSolSpent = 0;
    let totalSolReceived = 0;
    let totalMCAtEntry = 0; // Sum of all MC values at buy time
    let totalMCAtExit = 0; // Sum of all MC values at sell time
    
    // Get current data for fallback calculations (for old trades without locked MC)
    const currentMC = window.NX?.coinMarketData?.mcap || 0;
    const currentPrice = window.NX?.coinMarketData?.price || 0;
    const currentSolPrice = window.NX?.solPrice || 0;
    
    trades.forEach(trade => {
      // Calculate pricePerToken if missing (for old trades)
      const pricePerToken = trade.pricePerToken || (trade.tokenAmount > 0 ? (trade.solAmount / trade.tokenAmount) : 0);
      
      if (trade.type === 'buy') {
        totalBuys++;
        totalBought += trade.tokenAmount;
        totalSolSpent += trade.solAmount;
        
        // Use LOCKED MC from trade time, or calculate for old trades
        let mcAtTrade = trade.marketCapAtTrade;
        if (!mcAtTrade) {
          // Fallback for old trades: use their tokenPriceUSDLocked OR calculate from SOL price
          let tokenPriceUSD = trade.tokenPriceUSDLocked;
          if (!tokenPriceUSD) {
            // Ultra fallback: assume SOL price at trade was similar to now (best guess)
            const solPriceAtTrade = trade.solPriceAtTrade || currentSolPrice;
            tokenPriceUSD = pricePerToken * solPriceAtTrade;
          }
          
          if (tokenPriceUSD && currentMC > 0 && currentPrice > 0) {
            mcAtTrade = (tokenPriceUSD / currentPrice) * currentMC;
          }
        }
        if (mcAtTrade && mcAtTrade > 0) {
          totalMCAtEntry += mcAtTrade * trade.tokenAmount;
        }
      } else {
        totalSells++;
        totalSold += trade.tokenAmount;
        totalSolReceived += trade.solAmount;
        
        // Use LOCKED MC from trade time, or calculate for old trades
        let mcAtTrade = trade.marketCapAtTrade;
        if (!mcAtTrade) {
          // Fallback for old trades: use their tokenPriceUSDLocked OR calculate from SOL price
          let tokenPriceUSD = trade.tokenPriceUSDLocked;
          if (!tokenPriceUSD) {
            // Ultra fallback: assume SOL price at trade was similar to now (best guess)
            const solPriceAtTrade = trade.solPriceAtTrade || currentSolPrice;
            tokenPriceUSD = pricePerToken * solPriceAtTrade;
          }
          
          if (tokenPriceUSD && currentMC > 0 && currentPrice > 0) {
            mcAtTrade = (tokenPriceUSD / currentPrice) * currentMC;
          }
        }
        if (mcAtTrade && mcAtTrade > 0) {
          totalMCAtExit += mcAtTrade * trade.tokenAmount;
        }
      }
    });
    
    const avgEntry = totalBought > 0 ? (totalSolSpent / totalBought) : 0;
    const avgExit = totalSold > 0 ? (totalSolReceived / totalSold) : 0;
    
    // Use weighted average of LOCKED MC values (never changes once locked)
    const avgEntryMC = totalBought > 0 ? (totalMCAtEntry / totalBought) : 0;
    const avgExitMC = totalSold > 0 ? (totalMCAtExit / totalSold) : 0;
    
    console.log('[OrderBook] Stats using LOCKED MC values:', {
      avgEntryMC,
      avgExitMC,
      totalBuys,
      totalSells
    });
    
    return {
      totalBuys,
      totalSells,
      totalBought,
      totalSold,
      totalSolSpent,
      totalSolReceived,
      avgEntry,
      avgExit,
      avgEntryMC,
      avgExitMC
    };
  }
  
  // Calculate PnL for a sell trade
  function calculatePnLCell(sellTrade, avgEntry, avgEntryMC, userStats) {
    if (sellTrade.type !== 'sell') {
      return '<td class="p-2 text-center text-gray-600">—</td>';
    }
    
    // For incomplete trade histories (sold more than bought), show sell value only
    // Otherwise calculate accurate PnL based on avg entry
    const totalBought = userStats?.bought || 0;
    const totalSold = userStats?.sold || 0;
    
    // If we've sold more than we've tracked buying, we can't calculate accurate per-trade PnL
    // Show the proportional share of overall PnL instead
    if (totalSold > totalBought * 1.1 || !avgEntry || avgEntry === 0) {
      // Use overall PnL from stats (which is correct)
      const overallPnLUSD = userStats?.pnlUSD || 0;
      const overallPnLSOL = userStats?.pnl || 0;
      
      // Calculate this sell's share of total PnL based on proportion of tokens sold
      const sellProportion = totalSold > 0 ? (sellTrade.tokenAmount / totalSold) : 1;
      const tradePnLUSD = overallPnLUSD * sellProportion;
      const tradePnLSOL = overallPnLSOL * sellProportion;
      
      const isProfit = tradePnLSOL > 0;
      const pnlClass = isProfit ? 'text-emerald-400' : 'text-rose-400';
      const pnlIcon = isProfit ? '▲' : '▼';
      
      return `
        <td class="p-2 text-right">
          <div class="font-mono font-bold ${pnlClass}">
            ${pnlIcon} $${Math.abs(tradePnLUSD).toFixed(2)}
          </div>
          <div class="text-xs ${pnlClass}">
            ${tradePnLSOL >= 0 ? '+' : ''}${tradePnLSOL.toFixed(4)} SOL
          </div>
        </td>
      `;
    }
    
    // Complete trade history - calculate accurate per-trade PnL
    const exitPrice = sellTrade.tokenAmount > 0 ? (sellTrade.solAmount / sellTrade.tokenAmount) : 0;
    const pnlPerToken = exitPrice - avgEntry;
    const totalPnlSOL = pnlPerToken * sellTrade.tokenAmount;
    
    // Use LOCKED SOL price from trade if available
    const solPrice = sellTrade.solPriceAtTrade || window.NX?.solPrice || 220;
    const totalPnlUSD = totalPnlSOL * solPrice;
    
    const isProfit = totalPnlSOL > 0;
    const pnlClass = isProfit ? 'text-emerald-400' : 'text-rose-400';
    const pnlIcon = isProfit ? '▲' : '▼';
    
    return `
      <td class="p-2 text-right">
        <div class="font-mono font-bold ${pnlClass}">
          ${pnlIcon} $${Math.abs(totalPnlUSD).toFixed(2)}
        </div>
        <div class="text-xs ${pnlClass}">
          ${totalPnlSOL >= 0 ? '+' : ''}${totalPnlSOL.toFixed(4)} SOL
        </div>
      </td>
    `;
  }
  
  // Format timestamp for display
  function formatTimestamp(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    
    // For older trades, show date
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hours = date.getHours().toString().padStart(2, '0');
    const mins = date.getMinutes().toString().padStart(2, '0');
    return `${month}/${day} ${hours}:${mins}`;
  }
  
  // Event listeners
  amtInput?.addEventListener('input', handleAmountChange);
  submitBtn?.addEventListener('click', executeSwap);
  
  // Quick amount buttons
  let currentBalance = 0; // Will be updated by holdings system
  
  // Store user's token balance globally
  window.NX_updateBalance = function(balance) {
    currentBalance = balance;
  };
  
  // Setup quick button handlers
  function setupQuickButtons() {
    const quickBuyBtns = document.getElementById('quick-buy-btns');
    const quickSellBtns = document.getElementById('quick-sell-btns');
    const amtLabel = document.getElementById('amt-label');
    
    // SOL preset buttons (buy mode)
    if (quickBuyBtns) {
      quickBuyBtns.querySelectorAll('[data-sol]').forEach(btn => {
        btn.addEventListener('click', () => {
          const amount = btn.dataset.sol;
          if (amtInput) {
            amtInput.value = amount;
            handleAmountChange();
          }
        });
      });
      console.log('[Jupiter] SOL preset buttons attached');
    }
    
    // Percentage buttons (sell mode)
    if (quickSellBtns) {
      quickSellBtns.querySelectorAll('[data-pct]').forEach(btn => {
        btn.addEventListener('click', () => {
          const pct = parseFloat(btn.dataset.pct);
          if (!pct) return;
          
          if (currentBalance > 0) {
            const amount = (currentBalance * pct / 100).toFixed(6);
            if (amtInput) {
              amtInput.value = amount;
              handleAmountChange();
            }
          } else {
            showToast('error', 'No Token Balance', 'You need to own tokens before you can sell them', 3000);
          }
        });
      });
      console.log('[Jupiter] Percentage buttons attached');
    }
  }
  
  // Setup quick buttons immediately and after DOM loads
  setupQuickButtons();
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupQuickButtons);
  }
  
  // Buy/Sell mode toggle
  buyBtn?.addEventListener('click', () => {
    isBuyMode = true;
    const mint = getCurrentMint();
    const base = window.NX?.base || 'TOKEN';
    submitBtn.textContent = `Buy ${base}`;
    const amtLabel = document.getElementById('amt-label');
    const quickBuyBtns = document.getElementById('quick-buy-btns');
    const quickSellBtns = document.getElementById('quick-sell-btns');
    if (amtLabel) amtLabel.textContent = 'Amount (SOL)';
    // Show SOL presets, hide percentage buttons
    if (quickBuyBtns) quickBuyBtns.classList.remove('hidden');
    if (quickSellBtns) quickSellBtns.classList.add('hidden');
    amtInput.value = ''; // Clear amount on mode switch
    handleAmountChange();
  });
  
  sellBtn?.addEventListener('click', () => {
    isBuyMode = false;
    const base = window.NX?.base || 'TOKEN';
    submitBtn.textContent = `Sell ${base}`;
    const amtLabel = document.getElementById('amt-label');
    const quickBuyBtns = document.getElementById('quick-buy-btns');
    const quickSellBtns = document.getElementById('quick-sell-btns');
    if (amtLabel) amtLabel.textContent = `Amount (${base})`;
    // Show percentage buttons, hide SOL presets
    if (quickBuyBtns) quickBuyBtns.classList.add('hidden');
    if (quickSellBtns) quickSellBtns.classList.remove('hidden');
    amtInput.value = ''; // Clear amount on mode switch
    handleAmountChange();
  });
  
  console.log('[Jupiter] Swap integration loaded');
})();
</script>

    <!-- === Adrenaline overlay script === -->
    <script>
(() => {
  const tab = document.getElementById('adrenalineTab');
  const panel = document.getElementById('adrenalinePanel');
  const frame = document.getElementById('adrenalineFrame');
  const closeBtn = document.getElementById('adrenalineClose');
  const mainGrid = document.getElementById('mainGrid');
  if (!tab || !panel || !frame || !closeBtn) return;

  const viewBtns = Array.from(panel.querySelectorAll('.ad-view'));
  const STORAGE_KEY = 'nebula_adrenaline_view';
  let currentView = localStorage.getItem(STORAGE_KEY) || 'new';

  // 1) Load the iframe ONCE (no view param) and send the desired view after it loads
  frame.src = 'Adrenaline-official.html?embed=1';
  frame.addEventListener('load', () => { sendView(currentView, true); });

  // PostMessage to the iframe (the Adrenaline page listens for this)
  function sendView(view, scroll = true){
    try { frame.contentWindow.postMessage({ type: 'nx-ad-view', view, scroll }, '*'); } catch(e){}
  }

  function openPanel(){
    panel.classList.add('open');
    tab.setAttribute('aria-expanded','true');
    panel.setAttribute('aria-hidden','false');
    mainGrid?.classList.add('ad-open');   // create room; no overflow
  }
  function closePanel(){
    panel.classList.remove('open');
    tab.setAttribute('aria-expanded','false');
    panel.setAttribute('aria-hidden','true');
    mainGrid?.classList.remove('ad-open');
  }
  function togglePanel(){ panel.classList.contains('open') ? closePanel() : openPanel(); }

  tab.addEventListener('click', togglePanel);
  closeBtn.addEventListener('click', closePanel);
  document.addEventListener('keydown', e => { if (e.key === 'Escape') closePanel(); });

  // View buttons: open, highlight, and tell the iframe to switch & scroll
  viewBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const v = btn.dataset.view;
      if (v === currentView && panel.classList.contains('open')) return;
      currentView = v;
      localStorage.setItem(STORAGE_KEY, currentView);
      openPanel();
      setActiveButton(currentView);
      sendView(currentView, true);
    });
  });

  initView(currentView);  // only sets button state locally

  function initView(v){ setActiveButton(v); }
  function setActiveButton(v){
    viewBtns.forEach(b => {
      const active = b.dataset.view === v;
      b.classList.toggle('is-active', active);
      b.setAttribute('aria-selected', active ? 'true' : 'false');
    });
  }
})();
</script>
<script>
(function(){
  // Birdeye API configuration
  const BIRDEYE_KEY =
    window.NX_BIRDEYE_KEY ||
    window.NX?.BIRDEYE_KEY ||
    localStorage.getItem('BIRDEYE_KEY') ||
    '267367afba5b44f2b7398e53aba49f5f';
  const CHAIN = 'solana';
  const HEADERS = { 'X-API-KEY': BIRDEYE_KEY, 'x-chain': CHAIN, 'accept': 'application/json' };
  
  const qp = new URLSearchParams(location.search);
  let rawPair = qp.get('pair') || 'NEBULAX/SOL';
  let mint = (qp.get('mint') || '').trim();
  let pairAddr = (qp.get('pairAddr') || '').trim(); // Get pool/pair address from URL

  console.log('[CoinPage] URL params:', { rawPair, mint, pairAddr });

  // Try to get coin data from localStorage only if URL doesn't have mint (backward compatibility)
  let coinData = null;
  if (!mint) {
    try {
      const stored = localStorage.getItem('nebula_selected_coin');
      if (stored) {
        coinData = JSON.parse(stored);
        if (coinData.mint) mint = coinData.mint;
        if (coinData.pair) rawPair = coinData.pair;
        console.log('[CoinPage] Loaded from localStorage:', { mint, pair: rawPair });
      }
    } catch (e) {
      console.error('Error reading stored coin data:', e);
    }
  }
  
  if (!mint) {
    console.error('[CoinPage] No mint address found in URL or localStorage!');
    const titleEl = document.getElementById('coin-title');
    if (titleEl) titleEl.textContent = 'Error: No token address provided';
    return; // Stop execution if no mint
  }
  
  // Safely decode pair - handle already-decoded or malformed URLs
  let pair;
  try {
    pair = decodeURIComponent(rawPair).replace(/\s+/g,'').toUpperCase();
  } catch (e) {
    // If decoding fails, use as-is (might already be decoded)
    pair = rawPair.replace(/\s+/g,'').toUpperCase();
    console.warn('Could not decode pair, using as-is:', pair);
  }
  const [base, quote = 'SOL'] = pair.split('/');
  
  // Title row - update with proper coin info
  const titleEl = document.querySelector('#leftColPanel .nx-title');
  if (titleEl) {
    // Priority: use symbol if available, otherwise use base token symbol
    let displayName = coinData?.symbol?.toUpperCase() || base || 'UNKNOWN';
    let displayFull = coinData?.name || displayName;
    titleEl.textContent = `${displayName} — ${displayFull}`;
  }
  
  // Buy button text
  const submit = document.getElementById('submit-order');
  if (submit) submit.textContent = `Buy ${base}`;
  
  // Contract area - update the CA display under title
  const caDisplay = document.getElementById('title-ca');
  if (caDisplay && mint) {
    const shortCA = `${mint.slice(0, 6)}...${mint.slice(-6)}`;
    caDisplay.innerHTML = `<span class="text-zinc-400">${shortCA}</span>`;
    caDisplay.title = mint; // Full address on hover
  }

  // Expose current context for other scripts
  window.NX = Object.assign({}, window.NX || {}, { pair, base, quote, mint, coinData });
  
  // Dispatch event to let Jupiter know mint is ready
  window.dispatchEvent(new CustomEvent('nebula:mint:ready', { detail: { mint } }));
  
  // Format numbers for market cap, liquidity, volume (available globally)
  const fmt = (v) => {
    if (!v && v !== 0) return '—';
    const num = Math.abs(v);
    if (num >= 1e9) return `$${(v / 1e9).toFixed(2)}B`;
    if (num >= 1e6) return `$${(v / 1e6).toFixed(2)}M`;
    if (num >= 1e3) return `$${(v / 1e3).toFixed(2)}K`;
    if (num < 0.01) return `$${v.toExponential(2)}`;
    return `$${v.toFixed(2)}`;
  };
  
  // Format prices separately
  const fmtPrice = (v) => {
    if (!v && v !== 0) return '—';
    if (v < 0.00001) return `$${v.toExponential(4)}`;
    if (v < 0.01) return `$${v.toFixed(8)}`;
    if (v < 1) return `$${v.toFixed(6)}`;
    if (v < 100) return `$${v.toFixed(4)}`;
    return `$${v.toFixed(2)}`;
  };
  
  // Helper function to update metrics display (available globally)
  const updateMetricsDisplay = (p, mc, fd, lq, v, pct) => {
    const mcapBtn = document.getElementById('stat-mcap');
    const priceBtn = document.getElementById('stat-price');
    const liqBtn = document.getElementById('stat-liq');
    const fdvBtn = document.getElementById('stat-fdv');
    const volBtn = document.getElementById('stat-vol');
    
    if (mcapBtn) mcapBtn.innerHTML = `Market Cap: <span class="ml-1 text-emerald-400">${fmt(mc)}</span>`;
    if (priceBtn) {
      const priceColor = pct && pct >= 0 ? 'text-emerald-400' : 'text-rose-400';
      const priceStr = `${fmtPrice(p)}${pct ? ` <span class="${priceColor}">(${pct > 0 ? '+' : ''}${pct.toFixed(2)}%)</span>` : ''}`;
      priceBtn.innerHTML = `Price: <span class="ml-1 text-emerald-400">${priceStr}</span>`;
    }
    if (liqBtn) liqBtn.innerHTML = `Liquidity: <span class="ml-1 text-emerald-400">${fmt(lq)}</span>`;
    if (fdvBtn) fdvBtn.innerHTML = `FDV: <span class="ml-1 text-amber-300">${fmt(fd)}</span>`;
    if (volBtn) volBtn.innerHTML = `24h Vol: <span class="ml-1 text-emerald-400">${fmt(v)}</span>`;
  };
  
  // Fetch coin data from Birdeye if mint is available
  if (mint) {
    console.log('[CoinPage] Starting data fetch for mint:', mint);
    (async () => {
      try {
        // Fetch market data from Birdeye (may fail for new tokens)
        let md = {};
        try {
          console.log('[CoinPage] Fetching Birdeye market data...');
          const mdRes = await fetch(`https://public-api.birdeye.so/defi/v3/token/market-data?address=${mint}`, {
            headers: HEADERS
          });
          if (mdRes.ok) {
            const mdData = await mdRes.json();
            md = mdData?.data || mdData || {};
            console.log('[CoinPage] Birdeye data:', md);
          } else {
            console.warn(`[CoinPage] Birdeye market data returned ${mdRes.status}, will use DexScreener data`);
          }
        } catch (birdeyeError) {
          console.warn('[CoinPage] Birdeye API unavailable, using DexScreener data only:', birdeyeError.message);
        }
        
        // Update logo if available from Birdeye
        let logoURI = md.logoURI || md.logo_uri || md.image || null;
        const logoEl = document.getElementById('coin-logo');
        if (logoURI && logoEl) {
          console.log('Updating logo from Birdeye:', logoURI);
          logoEl.innerHTML = `<img src="${logoURI}" class="h-full w-full object-cover" alt="${base}" onerror="this.parentElement.innerHTML='${base?.substring(0,2) || '??'}'"/>`;
          logoEl.classList.remove('bg-gradient-to-br', 'from-cyan-500', 'to-purple-600');
        } else {
          console.log('No logo from Birdeye, will try DexScreener');
          // Show initials as fallback
          if (logoEl && base) logoEl.textContent = base.substring(0,2);
        }
        
        // Fetch price stats for 24h change (optional Birdeye enhancement)
        let priceChange24h = null;
        try {
          const psRes = await fetch(`https://public-api.birdeye.so/defi/v3/price/stats?address=${mint}`, {
            headers: HEADERS
          });
          if (psRes.ok) {
            const psData = await psRes.json();
            priceChange24h = psData?.data?.price_change_24h || null;
          }
        } catch (e) {
          console.warn('Birdeye price stats unavailable:', e.message);
        }
        
        // Fetch holder data - try Birdeye first, then Solscan as fallback
        let holdersCount = 0;
        try {
          const holderRes = await fetch(`https://public-api.birdeye.so/defi/v3/token/holder?address=${mint}&page=1&page_size=1`, {
            headers: HEADERS
          });
          if (holderRes.ok) {
            const hData = await holderRes.json();
            holdersCount = hData?.data?.total || hData?.total || 0;
          }
        } catch (e) {
          console.warn('Birdeye holders fetch failed, trying Solscan...', e);
        }
        
        // Fallback to Solscan if Birdeye didn't return holders
        if (!holdersCount || holdersCount === 0) {
          try {
            const solscanRes = await fetch(`https://public-api.solscan.io/token/holders?tokenAddress=${mint}&page=1&size=1`);
            if (solscanRes.ok) {
              const solscanData = await solscanRes.json();
              holdersCount = solscanData?.data?.total || solscanData?.total || 0;
              console.log('Solscan holders:', holdersCount);
            }
          } catch (e) {
            console.warn('Solscan holders fetch also failed:', e);
          }
        }
        
        // Fetch DexScreener data for Market Cap and FDV
        let dexData = {};
        try {
          console.log('[CoinPage] Fetching DexScreener data...');
          const dexRes = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mint}`);
          if (dexRes.ok) {
            const dexJson = await dexRes.json();
            const pairs = dexJson?.pairs || [];
            console.log('[CoinPage] DexScreener pairs found:', pairs.length);
            if (pairs.length > 0) {
              // Get pair with highest volume
              const pair = pairs.reduce((best, p) => 
                (p.volume?.h24 || 0) > (best.volume?.h24 || 0) ? p : best
              );
              console.log('[CoinPage] Selected pair:', pair);
              dexData = {
                price: parseFloat(pair.priceUsd) || 0,
                marketCap: pair.marketCap || 0,
                fdv: pair.fdv || 0,
                liquidity: parseFloat(pair.liquidity?.usd) || 0,
                volume24h: parseFloat(pair.volume?.h24) || 0,
                priceChange24h: parseFloat(pair.priceChange?.h24) || null,
                pairAddress: pair.pairAddress,
                logoURI: pair.info?.imageUrl || pair.baseToken?.logo || null
              };
              
              // Update logo from DexScreener if we don't have one yet
              if (dexData.logoURI && !logoURI) {
                logoURI = dexData.logoURI;
                console.log('Updating logo from DexScreener:', logoURI);
                const logoEl = document.getElementById('coin-logo');
                if (logoEl) {
                  logoEl.innerHTML = `<img src="${logoURI}" class="h-full w-full object-cover" alt="${base}" onerror="this.parentElement.innerHTML='${base?.substring(0,2) || '??'}'"/>`;
                  logoEl.classList.remove('bg-gradient-to-br', 'from-cyan-500', 'to-purple-600');
                }
              } else if (dexData.logoURI) {
                console.log('Logo already set from Birdeye, skipping DexScreener');
              } else {
                console.log('No logo available from either source');
              }
              
              // Update title with DexScreener data
              const titleEl = document.getElementById('coin-title');
              if (titleEl) {
                const symbol = pair.baseToken?.symbol || base || 'UNKNOWN';
                const name = pair.baseToken?.name || symbol;
                titleEl.textContent = `${symbol.toUpperCase()} — ${name}`;
                
                // Update window.NX.base with the correct token symbol from DexScreener
                if (window.NX && pair.baseToken?.symbol) {
                  window.NX.base = pair.baseToken.symbol.toUpperCase();
                  console.log('[CoinPage] Updated window.NX.base to:', window.NX.base);
                }
              }
              
              // Extract and display social links
              const socialInfo = pair.info || {};
              const websites = socialInfo.websites || [];
              const socials = socialInfo.socials || [];
              
              // Find Twitter/X link
              const twitterLink = socials.find(s => s.type === 'twitter')?.url || 
                                  socials.find(s => s.url?.includes('twitter.com') || s.url?.includes('x.com'))?.url;
              
              // Find Website link (first website if available)
              const websiteLink = websites.length > 0 ? websites[0].url : null;
              
              // Update social buttons
              const twitterBtn = document.getElementById('twitter-link');
              const websiteBtn = document.getElementById('website-link');
              const twitterPreview = document.getElementById('twitter-preview');
              const websitePreview = document.getElementById('website-preview');
              const twitterIframe = document.getElementById('twitter-iframe');
              const websiteIframe = document.getElementById('website-iframe');
              
              if (twitterLink && twitterBtn) {
                twitterBtn.classList.remove('hidden');
                twitterBtn.onclick = () => window.open(twitterLink, '_blank');
                
                // For Twitter, show styled link preview instead of iframe (Twitter blocks iframes)
                let twitterHoverTimeout;
                twitterBtn.addEventListener('mouseenter', () => {
                  twitterHoverTimeout = setTimeout(() => {
                    const username = twitterLink.match(/(?:twitter\.com|x\.com)\/([^\/\?]+)/)?.[1] || 'Unknown';
                    const tokenSymbol = window.NX?.base || 'TOKEN';
                    const tokenName = document.getElementById('coin-title')?.textContent?.split('—')?.[1]?.trim() || tokenSymbol;
                    
                    twitterPreview.innerHTML = `
                      <div style="padding: 1.5rem; display: flex; flex-direction: column; gap: 1rem; height: 100%; background: linear-gradient(135deg, rgba(0, 230, 255, 0.03), rgba(0, 230, 255, 0.01));">
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                          <div style="width: 48px; height: 48px; background: linear-gradient(135deg, #1DA1F2, #0d8bd9); border-radius: 50%; display: grid; place-items-center; box-shadow: 0 4px 12px rgba(29, 161, 242, 0.3);">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                              <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                            </svg>
                          </div>
                          <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 700; font-size: 1.125rem; color: var(--nx-cyan); text-shadow: 0 0 8px rgba(0, 230, 255, 0.3);">@${username}</div>
                            <div style="font-size: 0.875rem; color: #1DA1F2; font-weight: 500;">Twitter/X Profile</div>
                          </div>
                        </div>
                        <div style="padding: 1rem; background: rgba(0, 230, 255, 0.08); border: 1px solid rgba(0, 230, 255, 0.2); border-radius: 8px;">
                          <div style="color: #e0e7ff; font-size: 0.875rem; margin-bottom: 0.5rem; font-weight: 500;">Official ${tokenSymbol} Account</div>
                          <div style="color: #a1a5b7; font-size: 0.8rem; line-height: 1.5;">Follow for ${tokenName} updates, announcements, and community discussions.</div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; padding: 0.75rem; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                          <div style="text-align: center;"><div style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Platform</div><div style="font-size: 0.875rem; color: var(--nx-cyan); font-weight: 600;">Twitter/X</div></div>
                          <div style="text-align: center;"><div style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Type</div><div style="font-size: 0.875rem; color: var(--nx-cyan); font-weight: 600;">Social</div></div>
                        </div>
                        <div style="margin-top: auto; padding-top: 1rem; border-top: 1px solid rgba(0, 230, 255, 0.15); font-size: 0.75rem; color: #64748b; text-align: center;">
                          <div style="color: var(--nx-cyan); font-weight: 500; margin-bottom: 0.25rem;">Click button to open profile →</div>
                          <div style="font-family: monospace; opacity: 0.6; font-size: 0.7rem; word-break: break-all;">${twitterLink.substring(0, 50)}${twitterLink.length > 50 ? '...' : ''}</div>
                        </div>
                      </div>
                    `;
                    twitterPreview.classList.add('show');
                  }, 300);
                });
                
                twitterBtn.addEventListener('mouseleave', () => {
                  clearTimeout(twitterHoverTimeout);
                  twitterPreview.classList.remove('show');
                });
                
                console.log('[CoinPage] Twitter link set:', twitterLink);
              }
              
              if (websiteLink && websiteBtn) {
                websiteBtn.classList.remove('hidden');
                websiteBtn.onclick = () => window.open(websiteLink, '_blank');
                
                // Set up hover preview with fallback for blocked iframes
                let websiteHoverTimeout;
                websiteBtn.addEventListener('mouseenter', () => {
                  websiteHoverTimeout = setTimeout(() => {
                    try {
                      const url = new URL(websiteLink);
                      const hostname = url.hostname.replace('www.', '');
                      const tokenSymbol = window.NX?.base || 'TOKEN';
                      const tokenName = document.getElementById('coin-title')?.textContent?.split('—')?.[1]?.trim() || tokenSymbol;
                      let platformName = 'Website', platformColor = 'var(--nx-cyan)';
                      let platformIcon = `<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>`;
                      if (hostname.includes('instagram.com')) { platformName='Instagram'; platformColor='#E4405F'; platformIcon=`<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>`; }
                      else if (hostname.includes('reddit.com')) { platformName='Reddit'; platformColor='#FF4500'; platformIcon=`<circle cx="12" cy="12" r="10"></circle><circle cx="9" cy="10" r="1.5"></circle><circle cx="15" cy="10" r="1.5"></circle><path d="M9 15c.5.5 1.5 1 3 1s2.5-.5 3-1"></path>`; }
                      else if (hostname.includes('t.me') || hostname.includes('telegram')) { platformName='Telegram'; platformColor='#0088cc'; platformIcon=`<polygon points="22 2 2 8.67 8.5 12.5 13 22 14.5 17 22 2"></polygon>`; }
                      else if (hostname.includes('discord')) { platformName='Discord'; platformColor='#5865F2'; platformIcon=`<path d="M9 12c0 .8-.7 1.5-1.5 1.5S6 12.8 6 12s.7-1.5 1.5-1.5S9 11.2 9 12zm6 0c0 .8-.7 1.5-1.5 1.5S12 12.8 12 12s.7-1.5 1.5-1.5S15 11.2 15 12z"></path><path d="M20.3 4.7c-1.2-.6-2.5-1-3.8-1.3-.2.3-.4.7-.5 1-1.4-.2-2.8-.2-4.2 0-.2-.3-.3-.7-.5-1-1.4.3-2.6.7-3.8 1.3C2.4 8.8 1.5 12.8 2 16.7c1.6 1.2 3.1 1.9 4.6 2.4.4-.5.7-1 1-1.6-.5-.2-1-.5-1.5-.8l.4-.3c2.9 1.3 6.1 1.3 9 0l.4.3c-.5.3-1 .6-1.5.8.3.6.6 1.1 1 1.6 1.5-.5 3-1.2 4.6-2.4.5-4.5-.8-8.4-3.7-11.9z"></path>`; }
                      websitePreview.innerHTML = `<div style="padding: 1.5rem; display: flex; flex-direction: column; gap: 1rem; height: 100%; background: linear-gradient(135deg, rgba(0, 230, 255, 0.03), rgba(0, 230, 255, 0.01));"><div style="display: flex; align-items: center; gap: 0.75rem;"><div style="width: 48px; height: 48px; background: linear-gradient(135deg, ${platformColor}, ${platformColor}dd); border-radius: 50%; display: grid; place-items-center; box-shadow: 0 4px 12px ${platformColor}50;"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${platformIcon}</svg></div><div style="flex: 1; min-width: 0;"><div style="font-weight: 700; font-size: 1.125rem; color: var(--nx-cyan); text-shadow: 0 0 8px rgba(0, 230, 255, 0.3);">${hostname}</div><div style="font-size: 0.875rem; color: ${platformColor}; font-weight: 500;">${platformName}</div></div></div><div style="padding: 1rem; background: rgba(0, 230, 255, 0.08); border: 1px solid rgba(0, 230, 255, 0.2); border-radius: 8px;"><div style="color: #e0e7ff; font-size: 0.875rem; margin-bottom: 0.5rem; font-weight: 500;">Official ${tokenSymbol} ${platformName}</div><div style="color: #a1a5b7; font-size: 0.8rem; line-height: 1.5;">Visit the official ${tokenName} ${platformName.toLowerCase()} for more information and community engagement.</div></div><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; padding: 0.75rem; background: rgba(0, 0, 0, 0.2); border-radius: 8px;"><div style="text-align: center;"><div style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Platform</div><div style="font-size: 0.875rem; color: var(--nx-cyan); font-weight: 600;">${platformName}</div></div><div style="text-align: center;"><div style="font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem;">Type</div><div style="font-size: 0.875rem; color: var(--nx-cyan); font-weight: 600;">Web</div></div></div><div style="margin-top: auto; padding-top: 1rem; border-top: 1px solid rgba(0, 230, 255, 0.15); font-size: 0.75rem; color: #64748b; text-align: center;"><div style="color: var(--nx-cyan); font-weight: 500; margin-bottom: 0.25rem;">Click button to visit →</div><div style="font-family: monospace; opacity: 0.6; font-size: 0.7rem; word-break: break-all;">${websiteLink.substring(0, 50)}${websiteLink.length > 50 ? '...' : ''}</div></div></div>`;
                      websitePreview.classList.add('show');
                    } catch (e) { console.error('Error creating website preview:', e); }
                  }, 300);
                });
                
                websiteBtn.addEventListener('mouseleave', () => {
                  clearTimeout(websiteHoverTimeout);
                  websitePreview.classList.remove('show');
                });
                
                console.log('[CoinPage] Website link set:', websiteLink);
              }
              
              // Re-initialize Lucide icons for the social buttons
              if (window.lucide && typeof window.lucide.createIcons === 'function') {
                window.lucide.createIcons();
              }
            }
          }
        } catch (e) {
          console.warn('DexScreener fetch failed:', e);
        }
        
        // Extract and format data (prioritize DexScreener over Birdeye for new tokens)
        const price = dexData?.price || md.price || 0;
        const mcap = dexData?.marketCap || md.market_cap || md.market_cap_usd || 0;
        const fdv = dexData?.fdv || 0;
        const liquidity = dexData?.liquidity || md.liquidity || md.liquidity_usd || 0;
        const vol24h = dexData?.volume24h || md.v24hUsd || md.volume_usd_24h || 0;
        const pctChange24h = priceChange24h || dexData?.priceChange24h || null;
        
        // Initial metrics update using the global updateMetricsDisplay function
        updateMetricsDisplay(price, mcap, fdv, liquidity, vol24h, pctChange24h);
        
        // Live update metrics AND PnL boxes every 3 seconds using Jupiter + DexScreener
        const currentMintForUpdates = mint;
        let lastPrice = price;
        
        const liveUpdateInterval = setInterval(async () => {
          try {
            // Stop if user navigated away
            const newMint = new URLSearchParams(location.search).get('mint') || '';
            if (newMint !== currentMintForUpdates) {
              clearInterval(liveUpdateInterval);
              return;
            }
            
            // Try Jupiter Price API first (faster, more real-time)
            let jupiterPrice = null;
            try {
              const jupRes = await fetch(`https://api.jup.ag/price/v2?ids=${currentMintForUpdates}`);
              if (jupRes.ok) {
                const jupData = await jupRes.json();
                jupiterPrice = jupData?.data?.[currentMintForUpdates]?.price || null;
              }
            } catch (e) {
              // Jupiter failed, will fall back to DexScreener
            }
            
            // Get full data from DexScreener
            const dexRes = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${currentMintForUpdates}`);
            if (dexRes.ok) {
              const dexJson = await dexRes.json();
              const pairs = dexJson?.pairs || [];
              if (pairs.length > 0) {
                const pair = pairs.reduce((best, p) => 
                  (p.volume?.h24 || 0) > (best.volume?.h24 || 0) ? p : best
                );
                
                // Use Jupiter price if available (more real-time), otherwise DexScreener
                const livePrice = jupiterPrice || parseFloat(pair.priceUsd) || price;
                const liveMcap = pair.marketCap || mcap;
                const liveFdv = pair.fdv || fdv;
                const liveLiq = parseFloat(pair.liquidity?.usd) || liquidity;
                const liveVol = parseFloat(pair.volume?.h24) || vol24h;
                const livePct = parseFloat(pair.priceChange?.h24) || pctChange24h;
                
                updateMetricsDisplay(livePrice, liveMcap, liveFdv, liveLiq, liveVol, livePct);
                
                // Update coinMarketData for PnL calculations
                window.NX.coinMarketData = {
                  ...window.NX.coinMarketData,
                  price: livePrice,
                  mcap: liveMcap,
                  fdv: liveFdv,
                  liquidity: liveLiq,
                  vol24h: liveVol,
                  priceChange24h: livePct
                };
                
                // Trigger PnL box refresh (Holding and PnL boxes)
                if (window.refreshPnLBoxes) {
                  window.refreshPnLBoxes(livePrice);
                }
                
                // Flash effect if price changed significantly
                if (lastPrice && Math.abs((livePrice - lastPrice) / lastPrice) > 0.001) {
                  const priceBtn = document.getElementById('stat-price');
                  if (priceBtn) {
                    priceBtn.style.transition = 'background 0.2s';
                    priceBtn.style.background = livePrice > lastPrice ? 'rgba(52,211,153,0.3)' : 'rgba(248,113,113,0.3)';
                    setTimeout(() => { priceBtn.style.background = ''; }, 500);
                  }
                }
                lastPrice = livePrice;
              }
            }
          } catch (e) {
            // Silently fail live updates - don't break the interval
          }
        }, 3000);
        
        // Update Token Info panels
        const infoHolders = document.getElementById('info-holders');
        if (infoHolders) infoHolders.textContent = holdersCount.toLocaleString();
        
        // Update CA display in title
        const titleCA = document.getElementById('title-ca');
        if (titleCA) titleCA.textContent = mint;
        
        // UPDATE TITLE with real coin data after fetch (Birdeye fallback)
        const titleEl = document.getElementById('coin-title');
        if (titleEl && md.name && titleEl.textContent === 'Loading...') {
          titleEl.textContent = `${base?.toUpperCase() || 'TOKEN'} — ${md.name || base}`;
        }
        
        
        // Placeholder values for holder distribution (would need additional API calls)
        // These would typically come from a security analysis API
        const setIfExists = (id, value) => {
          const el = document.getElementById(id);
          if (el) el.textContent = value;
        };
        
        setIfExists('info-top10h', '—');
        setIfExists('info-devh', '—');
        setIfExists('info-snipersh', '—');
        setIfExists('info-insiders', '—');
        setIfExists('info-bundlers', '—');
        setIfExists('info-lpburned', '—');
        setIfExists('info-protraders', '—');
        setIfExists('info-dexpaid', '—');
        
        // Safety check: Only update if this is still the current coin (prevents stale async updates)
        const currentMint = new URLSearchParams(location.search).get('mint') || '';
        if (currentMint && currentMint !== mint) {
          console.warn(`Stale data detected: loaded ${mint} but current coin is ${currentMint}, skipping UI update`);
          return;
        }
        
        // Store data for other components
        window.NX.coinMarketData = {
          price, mcap, fdv, liquidity, vol24h, 
          priceChange24h: pctChange24h,
          verified: !!md.verified,
          holders: holdersCount
        };
        
        // Fetch SOL price for PnL calculations in order book
        try {
          const solPriceRes = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
          if (solPriceRes.ok) {
            const solPriceData = await solPriceRes.json();
            const solPrice = solPriceData?.solana?.usd || 0;
            window.NX.solPrice = solPrice;
            console.log('[CoinPage] SOL price fetched:', solPrice);
          }
        } catch (e) {
          console.warn('[CoinPage] Failed to fetch SOL price:', e);
          window.NX.solPrice = 0; // Default to 0 if fetch fails
        }
        
        console.log('Coin data loaded:', window.NX.coinMarketData);
        
        // Load GeckoTerminal chart with the pair address from URL
        await loadGeckoTerminalChart(mint, pairAddr);
      } catch (e) {
        console.error('[CoinPage] Error fetching coin data:', e);
        // Show error in UI
        const titleEl = document.getElementById('coin-title');
        if (titleEl) titleEl.textContent = `Error loading token data: ${e.message}`;
      }
    })();
  } else {
    console.warn('[CoinPage] No mint address provided, skipping data fetch');
  }
  
  // Load GeckoTerminal embedded chart with DexScreener fallback
  async function loadGeckoTerminalChart(mint, pairAddr) {
    const chartIframe = document.getElementById('chart-iframe');
    const chartLoading = document.getElementById('chart-loading');
    
    if (!chartIframe || !chartLoading) return;
    
    try {
      let poolAddress = pairAddr; // Use the pair address passed from the URL first
      
      // If no pool address from URL, try to get from sessionStorage (set by trending page)
      if (!poolAddress) {
        try {
          const poolMap = JSON.parse(sessionStorage.getItem('gt_pool_map') || '{}');
          poolAddress = poolMap[mint];
        } catch (e) {
          console.warn('[Chart] SessionStorage parse error:', e);
        }
      }
      
      // If still no pool address, try DexScreener first (more reliable)
      if (!poolAddress && mint) {
        try {
          console.log('[Chart] Fetching pool from DexScreener...');
          const dexRes = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mint}`);
          if (dexRes.ok) {
            const dexData = await dexRes.json();
            const pairs = dexData?.pairs || [];
            if (pairs.length > 0) {
              // Get pair with highest liquidity
              const bestPair = pairs.reduce((best, p) => 
                (parseFloat(p.liquidity?.usd || 0) > parseFloat(best.liquidity?.usd || 0)) ? p : best
              );
              poolAddress = bestPair.pairAddress;
              console.log('[Chart] Found pool from DexScreener:', poolAddress);
            }
          }
        } catch (dexError) {
          console.warn('[Chart] DexScreener lookup failed:', dexError.message);
        }
      }
      
      // Last resort: try GeckoTerminal API
      if (!poolAddress && mint) {
        try {
          console.log('[Chart] Trying GeckoTerminal API...');
          const response = await fetch(`https://api.geckoterminal.com/api/v2/search/pools?query=${mint}&network=solana`, {
            signal: AbortSignal.timeout(5000) // 5 second timeout
          });
          if (response.ok) {
            const data = await response.json();
            const pools = data?.data || [];
            if (pools.length > 0) {
              poolAddress = pools[0].id.split('_')[1]; // Extract pool address from format "solana_pooladdress"
              console.log('[Chart] Found pool from GeckoTerminal:', poolAddress);
            }
          }
        } catch (gtError) {
          console.warn('[Chart] GeckoTerminal API failed:', gtError.message);
        }
      }
      
      if (poolAddress) {
        // Embed GeckoTerminal chart iframe
        const embedUrl = `https://www.geckoterminal.com/solana/pools/${poolAddress}?embed=1&info=0&swaps=0`;
        chartIframe.src = embedUrl;
        chartIframe.style.display = 'block';
        chartLoading.style.display = 'none';
        console.log('[Chart] Chart loaded successfully:', poolAddress);
      } else {
        // Fallback: show DexScreener link
        chartLoading.innerHTML = `
          <div class="text-center">
            <div class="text-zinc-400 text-sm mb-2">Chart temporarily unavailable</div>
            <div class="text-xs text-zinc-500 mb-3">Pool lookup failed</div>
            <a href="https://dexscreener.com/solana/${mint}" target="_blank" 
               class="inline-flex items-center gap-2 px-4 py-2 bg-cyan-500/20 hover:bg-cyan-500/30 
                      text-cyan-400 rounded-lg border border-cyan-500/30 transition-colors text-sm">
              <span>View on DexScreener</span>
              <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                      d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/>
              </svg>
            </a>
          </div>
        `;
        console.warn('[Chart] No pool address found for mint:', mint);
      }
    } catch (e) {
      console.error('[Chart] Critical error loading chart:', e);
      chartLoading.innerHTML = `
        <div class="text-center">
          <div class="text-zinc-400 text-sm mb-2">Chart unavailable</div>
          <div class="text-xs text-zinc-500 mb-3">${e.message || 'Failed to load chart data'}</div>
          <a href="https://dexscreener.com/solana/${mint}" target="_blank" 
             class="inline-flex items-center gap-2 px-4 py-2 bg-cyan-500/20 hover:bg-cyan-500/30 
                    text-cyan-400 rounded-lg border border-cyan-500/30 transition-colors text-sm">
            <span>View on DexScreener</span>
            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                    d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/>
            </svg>
          </a>
        </div>
      `;
    }
  }
})();
</script>

    <!-- === Token Holdings & Stats Display === -->
<script>
(async function(){
  const statBought = document.getElementById('stat-bought');
  const statSold = document.getElementById('stat-sold');
  const statHolding = document.getElementById('stat-holding');
  const statPnl = document.getElementById('stat-pnl');
  const holdingsInfo = document.getElementById('holdings-info');
  
  // Get current mint from URL or localStorage fallback
  function getCurrentMint() {
    // First try URL
    const qp = new URLSearchParams(location.search);
    let mint = qp.get('mint') || '';
    
    if (mint) return mint;
    
    // Fallback to localStorage
    try {
      const stored = localStorage.getItem('nebula_selected_coin');
      if (stored) {
        const coinData = JSON.parse(stored);
        mint = coinData.mint || '';
        if (mint) return mint;
      }
    } catch (e) {
      console.error('[Holdings] Error reading localStorage:', e);
    }
    
    // Last resort: check window.NX global
    if (window.NX?.mint) {
      return window.NX.mint;
    }
    
    return '';
  }
  
  // formatNumber function moved earlier in code (before order book)
  
  // Fetch user's token balance
  async function fetchTokenBalance(mint, walletAddress) {
    try {
      const connection = new solanaWeb3.Connection(window.NX_RPC);
      const publicKey = new solanaWeb3.PublicKey(walletAddress);
      const mintPublicKey = new solanaWeb3.PublicKey(mint);
      
      // Get token accounts for this wallet
      const tokenAccounts = await connection.getParsedTokenAccountsByOwner(publicKey, {
        mint: mintPublicKey
      });
      
      if (tokenAccounts.value.length === 0) return 0;
      
      // Sum all token account balances (usually just 1)
      const totalBalance = tokenAccounts.value.reduce((sum, account) => {
        return sum + (account.account.data.parsed.info.tokenAmount.uiAmount || 0);
      }, 0);
      
      return totalBalance;
    } catch (error) {
      console.error('[Holdings] Error fetching balance:', error);
      return 0;
    }
  }
  
  // Refresh PnL boxes with live price (called every 3 seconds)
  window.refreshPnLBoxes = function(currentPrice) {
    const mint = getCurrentMint();
    if (!mint || !window.NXWallet?.isConnected()) return;
    
    const walletAddress = window.NXWallet.getAddress();
    if (!walletAddress) return;
    
    // Get order book stats
    if (!window.NXOrderBook?.calculateUserStats) return;
    
    const stats = window.NXOrderBook.calculateUserStats(mint, walletAddress.toString());
    
    // Calculate current holdings value using live price
    const balance = window.NX_currentBalance || 0; // Token balance stored globally
    const currentValue = balance * (currentPrice || 0);
    
    // Update Holding box with live USD value
    const statHolding = document.getElementById('stat-holding');
    const statHoldingTokens = document.getElementById('stat-holding-tokens');
    if (statHolding) {
      statHolding.textContent = currentValue > 0 ? `${formatNumber(currentValue)}` : '$0';
    }
    if (statHoldingTokens) {
      const tokenSymbol = window.NX?.base || 'TOKEN';
      statHoldingTokens.textContent = `${formatNumber(balance, true)} ${tokenSymbol}`;
    }
    
    // Recalculate PnL with live price
    const boughtUSD = stats.boughtUSD || 0;
    const soldUSD = stats.soldUSD || 0;
    const pnlValue = currentValue - boughtUSD + soldUSD; // Current value - bought + sold
    const pnlPct = boughtUSD > 0 ? ((pnlValue / boughtUSD) * 100) : 0;
    
    // Update PnL box
    const statPnl = document.getElementById('stat-pnl');
    const statPnlPct = document.getElementById('stat-pnl-pct');
    
    if (statPnl) {
      statPnl.textContent = `${pnlValue >= 0 ? '+' : ''}${formatNumber(Math.abs(pnlValue))}`;
      statPnl.className = `font-semibold ${pnlValue >= 0 ? 'text-emerald-400' : 'text-rose-400'}`;
    }
    if (statPnlPct) {
      statPnlPct.textContent = `${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(2)}%`;
      statPnlPct.className = `text-[10px] mt-0.5 ${pnlValue >= 0 ? 'text-emerald-400' : 'text-rose-400'}`;
    }
  };
  
  // Update holdings display
  async function updateHoldings() {
    const mint = getCurrentMint();
    if (!mint) {
      console.warn('[Holdings] No mint address found');
      return;
    }
    
    // Check wallet connection
    if (!window.NXWallet?.isConnected()) {
      holdingsInfo.textContent = 'Connect wallet to see holdings';
      return;
    }
    
    const walletAddress = window.NXWallet.getAddress();
    if (!walletAddress) {
      holdingsInfo.textContent = 'Connect wallet to see holdings';
      return;
    }
    
    // Show loading
    holdingsInfo.textContent = 'Loading holdings...';
    
    try {
      // Fetch balance
      const balance = await fetchTokenBalance(mint, walletAddress);
      
      // Get token info from NX global
      const tokenSymbol = window.NX?.base || 'TOKEN';
      const tokenPrice = window.NX?.coinMarketData?.price || 0;
      
      // Calculate USD value
      const usdValue = balance * tokenPrice;
      
      // Update holdings panels
      if (statHolding) {
        statHolding.textContent = usdValue > 0 ? `$${formatNumber(usdValue)}` : '$0';
      }
      
      // Update holdings info text
      if (balance > 0) {
        holdingsInfo.innerHTML = `<span class="text-cyan-400">${tokenSymbol}</span> Holdings: <span class="font-semibold text-zinc-300">${formatNumber(balance)} ${tokenSymbol}</span>`;
      } else {
        holdingsInfo.textContent = `You don't hold any ${tokenSymbol}`;
      }
      
      // Store balance globally for percentage buttons AND PnL refresh
      window.NX_currentBalance = balance; // Store for live PnL updates
      if (typeof window.NX_updateBalance === 'function') {
        window.NX_updateBalance(balance);
      }
      
      // Load real trade history from order book
      const statBought = document.getElementById('stat-bought');
      const statBoughtUSD = document.getElementById('stat-bought-usd');
      const statSold = document.getElementById('stat-sold');
      const statSoldUSD = document.getElementById('stat-sold-usd');
      const statPnl = document.getElementById('stat-pnl');
      const statPnlPct = document.getElementById('stat-pnl-pct');
      const statHoldingTokens = document.getElementById('stat-holding-tokens');
      
      if (window.NXWallet?.isConnected?.() && window.NXWallet?.publicKey) {
        const wallet = window.NXWallet.publicKey.toString();
        
        // Use global order book function
        if (window.NXOrderBook?.calculateUserStats) {
          const stats = window.NXOrderBook.calculateUserStats(mint, wallet);
          
          // Show SOL amounts in main display
          const boughtSOL = stats.solSpent || 0;
          const soldSOL = stats.solReceived || 0;
          const boughtUSD = stats.boughtUSD || 0;
          const soldUSD = stats.soldUSD || 0;
          
          if (statBought) statBought.textContent = `${boughtSOL.toFixed(3)} SOL`;
          if (statBoughtUSD) statBoughtUSD.textContent = `$${formatNumber(boughtUSD)}`;
          if (statSold) statSold.textContent = `${soldSOL.toFixed(3)} SOL`;
          if (statSoldUSD) statSoldUSD.textContent = `$${formatNumber(soldUSD)}`;
          
          // Calculate PnL: Current holdings value - Amount spent
          const currentValue = usdValue; // From holdings calculation above
          const pnlValue = currentValue - boughtUSD + soldUSD; // Current value - bought + sold
          const pnlPct = boughtUSD > 0 ? ((pnlValue / boughtUSD) * 100) : 0;
          
          if (statPnl) {
            statPnl.textContent = `${pnlValue >= 0 ? '+' : ''}$${formatNumber(Math.abs(pnlValue))}`;
            statPnl.className = `font-semibold ${pnlValue >= 0 ? 'text-emerald-400' : 'text-rose-400'}`;
          }
          if (statPnlPct) {
            statPnlPct.textContent = `${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(2)}%`;
            statPnlPct.className = `text-[10px] mt-0.5 ${pnlValue >= 0 ? 'text-emerald-400' : 'text-rose-400'}`;
          }
          if (statHoldingTokens) {
            statHoldingTokens.textContent = `${formatNumber(balance, true)} ${tokenSymbol}`;
          }
          
          console.log('[Holdings] Stats calculated:', stats, 'Current Value:', currentValue, 'PnL:', pnlValue);
        }
      } else {
        if (statBought) statBought.textContent = '0 SOL';
        if (statBoughtUSD) statBoughtUSD.textContent = '$0';
        if (statSold) statSold.textContent = '0 SOL';
        if (statSoldUSD) statSoldUSD.textContent = '$0';
        if (statPnl) {
          statPnl.textContent = '$0';
          statPnl.className = 'font-semibold text-gray-400';
        }
        if (statPnlPct) {
          statPnlPct.textContent = '0%';
          statPnlPct.className = 'text-[10px] mt-0.5 text-zinc-500';
        }
      }
      
      console.log('[Holdings] Balance loaded:', { balance, tokenSymbol, usdValue });
    } catch (error) {
      console.error('[Holdings] Error updating holdings:', error);
      holdingsInfo.textContent = 'Error loading holdings';
    }
  }
  
  // Stat boxes flip animation
  let statsFlipped = false;
  
  function flipStatBoxes() {
    statsFlipped = !statsFlipped;
    
    const statBought = document.getElementById('stat-bought');
    const statBoughtUSD = document.getElementById('stat-bought-usd');
    const statSold = document.getElementById('stat-sold');
    const statSoldUSD = document.getElementById('stat-sold-usd');
    const statHolding = document.getElementById('stat-holding');
    const statHoldingTokens = document.getElementById('stat-holding-tokens');
    const statPnl = document.getElementById('stat-pnl');
    const statPnlPct = document.getElementById('stat-pnl-pct');
    
    // Swap content and classes for all boxes
    function swapElements(elem1, elem2) {
      if (!elem1 || !elem2) return;
      const tempText = elem1.textContent;
      const tempClass = elem1.className;
      const tempStyle = elem1.getAttribute('style') || '';
      
      elem1.textContent = elem2.textContent;
      elem1.className = elem2.className;
      if (elem2.getAttribute('style')) {
        elem1.setAttribute('style', elem2.getAttribute('style'));
      } else {
        elem1.removeAttribute('style');
      }
      
      elem2.textContent = tempText;
      elem2.className = tempClass;
      if (tempStyle) {
        elem2.setAttribute('style', tempStyle);
      } else {
        elem2.removeAttribute('style');
      }
    }
    
    // Swap all pairs
    swapElements(statBought, statBoughtUSD);
    swapElements(statSold, statSoldUSD);
    swapElements(statHolding, statHoldingTokens);
    swapElements(statPnl, statPnlPct);
    
    console.log('[Stats] Boxes flipped:', statsFlipped);
  }
  
  // Add click listeners to all stat boxes
  document.addEventListener('DOMContentLoaded', () => {
    const statBoxes = document.querySelectorAll('[data-stat-box]');
    statBoxes.forEach(box => {
      box.addEventListener('click', flipStatBoxes);
    });
    console.log('[Stats] Flip listeners attached to', statBoxes.length, 'boxes');
  });
  
  // Initialize on page load
  await updateHoldings();
  
  // Initialize order book display
  try {
    setTimeout(() => {
      if (window.NXOrderBook?.refreshDisplay) {
        window.NXOrderBook.refreshDisplay();
      }
    }, 1000); // Wait for UI to load
  } catch (error) {
    console.error('[OrderBook] Failed to initialize:', error);
  }
  
  // Update when wallet connects/disconnects
  window.addEventListener('nxwallet:connected', updateHoldings);
  window.addEventListener('nxwallet:disconnected', () => {
        if (statBought) statBought.textContent = '0 SOL';
        if (statBoughtUSD) statBoughtUSD.textContent = '$0';
        if (statSold) statSold.textContent = '0 SOL';
        if (statSoldUSD) statSoldUSD.textContent = '$0';
        if (statHolding) statHolding.textContent = '$0';
        if (statHoldingTokens) statHoldingTokens.textContent = '0 tokens';
        if (statPnl) {
          statPnl.textContent = '$0';
          statPnl.className = 'font-semibold text-gray-400';
        }
        if (statPnlPct) {
          statPnlPct.textContent = '0%';
          statPnlPct.className = 'text-[10px] mt-0.5 text-zinc-500';
        }
        if (holdingsInfo) holdingsInfo.textContent = 'Connect wallet to see holdings';
        // Reset balance for percentage buttons
        if (typeof window.NX_updateBalance === 'function') {
          window.NX_updateBalance(0);
        }
      });  // Update immediately when Jupiter swap completes
  window.addEventListener('jupiter:swap:complete', (e) => {
    console.log('[Holdings] Jupiter swap completed, refreshing...', e.detail);
    setTimeout(updateHoldings, 1000); // 1 second delay for blockchain to settle
  });
  
  // Update when SOL balance changes (indicates potential transaction)
  window.addEventListener('nebula:sol:changed', () => {
    setTimeout(updateHoldings, 2000); // Delay to let transaction settle
  });
  
  console.log('[Holdings] Stats system loaded');
})();
</script>

    <!-- === /Adrenaline overlay script === -->
<script>
/* === NebulaX Core (themes, header hydrate, routing hooks) === */
(function(){
  const UserStore={
    key:'nx_user',
    state:{ wallet:null, theme:'default', pfp:{type:'builtin',url:'/pfp/default.png'} },
    load(){ try{ Object.assign(this.state, JSON.parse(localStorage.getItem(this.key)||'{}')); }catch{} },
    save(){ localStorage.setItem(this.key, JSON.stringify(this.state)); }
  };
  UserStore.load();

  const Theme={
    init(){
      const t = UserStore.state.theme || 'default';
      document.documentElement.setAttribute('data-theme', t);
      const sel = document.getElementById('nx-theme');
      if (sel) sel.value = t;
      sel?.addEventListener('change', (e)=>{
        const v=e.target.value;
        document.documentElement.setAttribute('data-theme', v);
        UserStore.state.theme=v; UserStore.save();
      });
    }
  };

  const Header={
    initActiveTab(){
      const here = location.pathname.replace(/\/+$/,'') || '/NebulaX.html';
      document.querySelectorAll('.nx-tab').forEach(a=>{
        const route = a.getAttribute('data-route');
        if (!route) return;
        if (route===here) a.classList.add('active');
        else a.classList.remove('active');
        a.addEventListener('click',(e)=>{
          // allow normal navigation
        });
      });
    },
    initSearch(){
      const input = document.getElementById('nx-search');
      const btn   = document.getElementById('nx-search-btn');
      if(!input||!btn) return;
      const go = ()=>{
        const q = (input.value||'').trim();
        if(!q) return;
        // Route to coin page convention: /Coinpage-Official.html?query=...
        location.href = `/Coinpage-Official.html?query=${encodeURIComponent(q)}`;
      };
      btn.addEventListener('click', go);
      input.addEventListener('keydown', (e)=>{ if(e.key==='Enter') go(); });
    },
    initPfp(){
      const img = document.getElementById('nx-pfp');
      if(img) img.src = (UserStore.state.pfp?.url)||'/pfp/default.png';
      const btn = document.getElementById('nx-profile');
      btn?.addEventListener('click',()=>{
        // simple MVP: cycle built-ins; later open profile modal
        const choices=['/pfp/default.png','/pfp/nx01.png','/pfp/nx02.png'];
        const idx = Math.max(0, choices.indexOf(UserStore.state.pfp?.url));
        const next = choices[(idx+1)%choices.length];
        UserStore.state.pfp={type:'builtin',url:next}; UserStore.save();
        if(img) img.src=next;
      });
    },
    initStore(){
      const a = document.getElementById('nx-store');
      if(!a) return;
      // keep as a link; if you make a modal later, hydrate here
    },
    initWallet(){
      const w = document.getElementById('nx-wallet');
      w?.addEventListener('click', ()=>{
        // hook your wallet adapter here
        alert('Connect wallet (hook your adapter)');
      });
    },
    mount(){ this.initActiveTab(); this.initSearch(); this.initPfp(); this.initStore(); this.initWallet(); }
  };

  document.addEventListener('DOMContentLoaded', ()=>{
    Theme.init();
    Header.mount();
  });
})();
</script>

<!-- PnL Card Feature -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<!-- PnL Card Modal -->
<div id="pnl-modal" class="fixed inset-0 z-[9999] hidden flex items-center justify-center bg-black/90 backdrop-blur-md p-4 perspective-[2000px]">
    <div class="flex flex-col items-center gap-4 perspective-[2000px]">
        <!-- The Card -->
        <div id="pnl-card" class="relative w-[320px] h-[480px] rounded-[24px] overflow-hidden select-none transform-style-3d transition-transform hover:scale-105 duration-300 border border-white/10 shadow-[0_0_50px_rgba(0,255,255,0.15)] bg-[#0f1219]">
            <!-- Glass Background -->
            <div class="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMSIgY3k9IjEiIHI9IjEiIGZpbGw9InJnYmEoMjU1LDI1NSwyNTUsMC4wNSkiLz48L3N2Zz4=')] opacity-20 z-0"></div>
            <div class="absolute inset-0 bg-gradient-to-br from-[#1a1f35]/95 via-[#0f1219]/90 to-[#000]/95 backdrop-blur-2xl z-0"></div>
            
            <!-- Animated Sparkle Overlay -->
            <div id="pnl-sparkle-overlay" class="absolute inset-0 z-10 pointer-events-none animate-sparkle opacity-50 mix-blend-overlay bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSIxIiBmaWxsPSJ3aGl0ZSIvPjwvc3ZnPg==')]"></div>

            <!-- Shiny Border Effect -->
            <div id="pnl-border-effect" class="absolute inset-0 rounded-[24px] border-[1px] border-white/20 z-20 pointer-events-none shadow-[inset_0_0_20px_rgba(255,255,255,0.05)]"></div>
            
            <!-- Content Container -->
            <div class="relative z-30 h-full flex flex-col p-6">
                <!-- Header: User Info -->
                <div class="flex items-center gap-3 mb-6">
                    <div class="w-10 h-10 rounded-full border-2 border-cyan-400/50 overflow-hidden bg-black/50 shadow-[0_0_10px_rgba(34,211,238,0.3)]">
                        <img id="pnl-user-pfp" src="assets/NebulaX-logo.png" class="w-full h-full object-cover" onerror="this.src='assets/NebulaX-logo.png'">
                    </div>
                    <div>
                        <div id="pnl-username" class="font-bold text-white text-sm tracking-wide drop-shadow-[0_0_5px_rgba(255,255,255,0.5)]">@NebulaTrader</div>
                        <div class="text-[10px] text-cyan-400/80 font-mono tracking-widest">NEBULAX TRADER</div>
                    </div>
                    <div class="ml-auto">
                        <img src="assets/nebby_pnl.png" class="w-8 h-8 opacity-80 drop-shadow-[0_0_10px_rgba(34,211,238,0.5)]" onerror="this.src='games/Nebby Run/assets/nebby_static.png'">
                    </div>
                </div>

                <!-- Main PnL -->
                <div class="text-center mb-4 relative">
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/5 to-transparent blur-xl transform -skew-x-12"></div>
                    <div id="pnl-value-display" class="relative text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-emerald-400 to-cyan-400 drop-shadow-[0_0_25px_rgba(52,211,153,0.4)] filter contrast-125">
                        +0.00%
                    </div>
                    <div id="pnl-amount-display" class="relative text-lg text-emerald-400/90 font-mono mt-1 font-bold tracking-wide drop-shadow-[0_0_5px_rgba(52,211,153,0.5)]">+$0.00</div>
                </div>

                <!-- Nebby Mascot Centerpiece with Tech Background -->
                <div class="flex-1 relative flex items-center justify-center my-2 group perspective-[500px]">
                    <!-- Tech Rings -->
                    <div id="pnl-ring-1" class="absolute w-48 h-48 rounded-full border border-cyan-500/20 border-dashed animate-[spin_20s_linear_infinite]"></div>
                    <div id="pnl-ring-2" class="absolute w-40 h-40 rounded-full border border-purple-500/20 border-dotted animate-[spin_15s_linear_infinite_reverse]"></div>
                    <div id="pnl-ring-3" class="absolute w-32 h-32 rounded-full border-2 border-white/5 animate-pulse"></div>
                    
                    <!-- Glow -->
                    <div id="pnl-glow" class="absolute inset-0 bg-cyan-500/5 blur-[60px] rounded-full transform scale-75"></div>
                    
                    <!-- Nebby -->
                    <img src="assets/nebby_pnl.png" class="relative w-48 h-48 object-contain drop-shadow-[0_0_30px_rgba(34,211,238,0.4)] animate-float filter brightness-110 contrast-110 z-10" onerror="this.src='games/Nebby Run/assets/nebby_static.png'">
                </div>

                <!-- Stats Grid -->
                <div class="grid grid-cols-2 gap-3 mt-auto mb-4">
                    <div class="bg-white/5 rounded-xl p-3 border border-white/10 backdrop-blur-md shadow-[0_4px_10px_rgba(0,0,0,0.2)] hover:bg-white/10 transition-colors">
                        <div class="text-[10px] text-zinc-400 uppercase tracking-wider mb-1 font-bold">Total Sold</div>
                        <div id="pnl-holding-value" class="text-white font-bold font-mono text-lg drop-shadow-[0_0_5px_rgba(255,255,255,0.3)]">$0.00</div>
                    </div>
                    <div class="bg-white/5 rounded-xl p-3 border border-white/10 backdrop-blur-md shadow-[0_4px_10px_rgba(0,0,0,0.2)] hover:bg-white/10 transition-colors">
                        <div class="text-[10px] text-zinc-400 uppercase tracking-wider mb-1 font-bold">Hold Time</div>
                        <div id="pnl-hold-time" class="text-white font-bold font-mono text-lg drop-shadow-[0_0_5px_rgba(255,255,255,0.3)]">--</div>
                    </div>
                </div>

                <!-- Footer -->
                <div class="text-center pt-3 border-t border-white/10 flex justify-between items-center px-2">
                    <div class="text-[10px] font-bold tracking-[0.2em] text-cyan-400/60">NEBULAX</div>
                    <div class="text-[10px] font-bold tracking-[0.2em] text-purple-400/60">SERIES I</div>
                </div>
            </div>
            
            <!-- Holographic Overlay -->
            <div id="pnl-holographic-overlay" class="absolute inset-0 bg-gradient-to-tr from-transparent via-white/10 to-transparent opacity-40 pointer-events-none z-40 mix-blend-overlay"></div>
            <div id="pnl-shine-overlay" class="absolute -inset-[100%] bg-gradient-to-r from-transparent via-white/20 to-transparent rotate-45 animate-shine pointer-events-none z-50"></div>
        </div>

        <!-- Controls -->
        <div class="flex gap-3 mt-4">
            <button id="pnl-close-btn" class="px-6 py-2 rounded-full bg-zinc-800 text-zinc-400 hover:bg-zinc-700 hover:text-white transition-colors text-sm font-medium">Close</button>
            <button id="pnl-save-btn" class="px-6 py-2 rounded-full bg-gradient-to-r from-cyan-500 to-blue-500 text-white hover:shadow-[0_0_20px_rgba(6,182,212,0.4)] transition-all text-sm font-bold flex items-center gap-2">
                <i data-lucide="download" class="w-4 h-4"></i> Save Card
            </button>
        </div>
    </div>
</div>

<style>
@keyframes float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
}
@keyframes shine {
    0% { transform: translateX(-100%) rotate(45deg); }
    100% { transform: translateX(100%) rotate(45deg); }
}
@keyframes sparkle {
    0%, 100% { opacity: 0.3; transform: scale(1); }
    50% { opacity: 0.6; transform: scale(1.1); }
}
.animate-float { animation: float 4s ease-in-out infinite; }
.animate-shine { animation: shine 3s ease-in-out infinite; }
.animate-sparkle { animation: sparkle 2s ease-in-out infinite; }
@keyframes unfold {
    0% { opacity: 0; transform: rotateX(-90deg) scale(0.8) translateY(50px); filter: blur(10px); }
    60% { opacity: 1; transform: rotateX(10deg) scale(1.05) translateY(-10px); filter: blur(0px); }
    100% { transform: rotateX(0) scale(1) translateY(0); }
}
.animate-unfold { animation: unfold 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; transform-origin: top center; }
</style>

<script>
(function(){
    const modal = document.getElementById('pnl-modal');
    const btn = document.getElementById('btn-share-pnl');
    const closeBtn = document.getElementById('pnl-close-btn');
    const saveBtn = document.getElementById('pnl-save-btn');
    
    if(!btn || !modal) return;

    function updateCardData() {
        // Get data from page
        const pnlText = document.getElementById('stat-pnl')?.textContent || '$0';
        const pnlPctText = document.getElementById('stat-pnl-pct')?.textContent || '0%';
        // Use Total Sold instead of Holding Value
        const soldText = document.getElementById('stat-sold-usd')?.textContent || '$0';
        const pfpSrc = document.getElementById('nx-pfp')?.src || 'assets/NebulaX-logo.png';
        
        // Update Card
        document.getElementById('pnl-user-pfp').src = pfpSrc;
        document.getElementById('pnl-value-display').textContent = pnlPctText;
        document.getElementById('pnl-amount-display').textContent = pnlText;
        document.getElementById('pnl-holding-value').textContent = soldText;
        
        // Calculate Hold Time from actual trade history
        let holdTimeText = '--';
        try {
            const ORDER_BOOK_KEY = 'nebulax_order_book';
            const orderBook = JSON.parse(localStorage.getItem(ORDER_BOOK_KEY) || '[]');
            const currentMint = window.NX?.mint || null;
            
            console.log('[PnL Card] Current mint:', currentMint);
            console.log('[PnL Card] Order book length:', orderBook.length);
            
            if (currentMint && orderBook.length > 0) {
                // Filter trades for this token - use tokenMint and type fields
                const tokenTrades = orderBook.filter(t => t.tokenMint === currentMint);
                console.log('[PnL Card] Token trades found:', tokenTrades.length);
                
                const buys = tokenTrades.filter(t => t.type === 'buy');
                const sells = tokenTrades.filter(t => t.type === 'sell');
                
                console.log('[PnL Card] Buys:', buys.length, 'Sells:', sells.length);
                
                if (buys.length > 0) {
                    let totalHoldTime = 0;
                    let holdCount = 0;
                    
                    // Calculate hold times using FIFO matching (same as portfolio analytics)
                    const buyTimes = buys.map(b => b.timestamp).sort((a, b) => a - b);
                    
                    sells.forEach(sell => {
                        if (buyTimes.length > 0) {
                            const buyTime = buyTimes.shift(); // FIFO
                            const holdMs = sell.timestamp - buyTime;
                            totalHoldTime += holdMs;
                            holdCount++;
                        }
                    });
                    
                    // If still holding (no sells or more buys than sells), use first buy to now
                    if (holdCount === 0 && buys.length > 0) {
                        const firstBuy = Math.min(...buys.map(b => b.timestamp));
                        const holdMs = Date.now() - firstBuy;
                        totalHoldTime = holdMs;
                        holdCount = 1;
                        console.log('[PnL Card] Still holding, using first buy to now:', holdMs);
                    }
                    
                    if (holdCount > 0) {
                        const avgMs = totalHoldTime / holdCount;
                        console.log('[PnL Card] Average hold time (ms):', avgMs);
                        
                        // Round to nearest 5 minutes
                        const totalMinutes = Math.floor(avgMs / (1000 * 60));
                        const roundedMinutes = Math.round(totalMinutes / 5) * 5;
                        
                        const hours = Math.floor(roundedMinutes / 60);
                        const days = Math.floor(hours / 24);
                        const remainingMinutes = roundedMinutes % 60;
                        
                        if (days > 0) {
                            holdTimeText = `${days}d ${hours % 24}h`;
                        } else if (hours > 0) {
                            holdTimeText = `${hours}h ${remainingMinutes}m`;
                        } else if (roundedMinutes > 0) {
                            holdTimeText = `${roundedMinutes}m`;
                        } else {
                            holdTimeText = 'Just now';
                        }
                        
                        console.log('[PnL Card] Final hold time text:', holdTimeText);
                    }
                }
            } else {
                console.log('[PnL Card] Missing data - mint:', !!currentMint, 'orderBook:', orderBook.length);
            }
        } catch(e) {
            console.error('[PnL Card] Failed to calculate hold time:', e);
        }
        document.getElementById('pnl-hold-time').textContent = holdTimeText;
        
        // Color logic - check both $ amount and percentage for negative
        const isPositive = !pnlText.includes('-') && !pnlPctText.includes('-');
        const valDisplay = document.getElementById('pnl-value-display');
        const amtDisplay = document.getElementById('pnl-amount-display');
        
        if(isPositive) {
            valDisplay.className = "relative text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-emerald-400 to-cyan-400 drop-shadow-[0_0_25px_rgba(52,211,153,0.4)] filter contrast-125";
            amtDisplay.className = "relative text-lg text-emerald-400/90 font-mono mt-1 font-bold tracking-wide drop-shadow-[0_0_5px_rgba(52,211,153,0.5)]";
        } else {
            valDisplay.className = "relative text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-rose-500 to-orange-500 drop-shadow-[0_0_25px_rgba(244,63,94,0.4)] filter contrast-125";
            amtDisplay.className = "relative text-lg text-rose-500/90 font-mono mt-1 font-bold tracking-wide drop-shadow-[0_0_5px_rgba(244,63,94,0.5)]";
        }
    }

    btn.addEventListener('click', () => {
        updateCardData();
        modal.classList.remove('hidden');
        
        // Trigger Unfold Animation
        const card = document.getElementById('pnl-card');
        card.classList.remove('animate-unfold');
        void card.offsetWidth; // Force reflow
        card.classList.add('animate-unfold');
    });

    closeBtn.addEventListener('click', () => {
        modal.classList.add('hidden');
    });

    modal.addEventListener('click', (e) => {
        if(e.target === modal) modal.classList.add('hidden');
    });

    saveBtn.addEventListener('click', async () => {
        const card = document.getElementById('pnl-card');
        const pnlValueDisplay = document.getElementById('pnl-value-display');
        const pnlAmountDisplay = document.getElementById('pnl-amount-display');
        const holographicOverlay = document.getElementById('pnl-holographic-overlay');
        const shineOverlay = document.getElementById('pnl-shine-overlay');
        const sparkleOverlay = document.getElementById('pnl-sparkle-overlay');
        const borderEffect = document.getElementById('pnl-border-effect');
        const ring1 = document.getElementById('pnl-ring-1');
        const ring2 = document.getElementById('pnl-ring-2');
        const ring3 = document.getElementById('pnl-ring-3');
        const glow = document.getElementById('pnl-glow');
        
        const originalTransform = card.style.transform;
        const originalAnimation = card.className;
        
        // Store original classes for gradient text elements
        const pnlValueClasses = pnlValueDisplay.className;
        const pnlAmountClasses = pnlAmountDisplay.className;
        
        // Remove animation and transform for clean capture
        card.classList.remove('animate-unfold');
        card.style.transform = 'none';
        
        // Hide all animated/blend overlays during capture
        holographicOverlay.style.display = 'none';
        shineOverlay.style.display = 'none';
        sparkleOverlay.style.display = 'none';
        borderEffect.style.display = 'none';
        ring1.style.display = 'none';
        ring2.style.display = 'none';
        ring3.style.display = 'none';
        glow.style.display = 'none';
        
        // Replace text-transparent with solid color for capture
        // Check if negative (red) or positive (green)
        const isNegative = pnlValueDisplay.textContent.includes('−') || pnlValueDisplay.textContent.includes('-');
        
        if (isNegative) {
            // Red/Pink gradient for losses
            pnlValueDisplay.className = 'relative text-5xl font-black text-rose-400 drop-shadow-[0_0_25px_rgba(251,113,133,0.6)] filter contrast-125';
            pnlAmountDisplay.className = 'relative text-xl font-bold text-rose-300 drop-shadow-[0_0_15px_rgba(251,113,133,0.4)]';
        } else {
            // Green/Cyan gradient for gains
            pnlValueDisplay.className = 'relative text-5xl font-black text-emerald-400 drop-shadow-[0_0_25px_rgba(52,211,153,0.6)] filter contrast-125';
            pnlAmountDisplay.className = 'relative text-xl font-bold text-cyan-300 drop-shadow-[0_0_15px_rgba(34,211,238,0.4)]';
        }
        
        // Give a moment for styles to settle
        await new Promise(resolve => setTimeout(resolve, 100));
        
        try {
            if (typeof html2canvas === 'undefined') {
                throw new Error('html2canvas not loaded');
            }
            
            const canvas = await html2canvas(card, {
                backgroundColor: null,
                scale: 2,
                logging: false,
                useCORS: true,
                allowTaint: true,
                imageTimeout: 0,
                removeContainer: false
            });
            
            // Convert to blob for better compatibility
            canvas.toBlob((blob) => {
                if (!blob) {
                    alert('Failed to create image. Please try again.');
                    return;
                }
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `nebulax-pnl-${Date.now()}.png`;
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 'image/png');
        } catch(e) {
            console.error('Capture failed:', e);
            alert(`Failed to save image: ${e.message}`);
        } finally {
            // Restore original state
            card.style.transform = originalTransform;
            card.className = originalAnimation;
            pnlValueDisplay.className = pnlValueClasses;
            pnlAmountDisplay.className = pnlAmountClasses;
            holographicOverlay.style.display = '';
            shineOverlay.style.display = '';
            sparkleOverlay.style.display = '';
            borderEffect.style.display = '';
            ring1.style.display = '';
            ring2.style.display = '';
            ring3.style.display = '';
            glow.style.display = '';
        }
    });
})();
</script>

  </body>
</html>

